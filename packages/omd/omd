#!/usr/bin/python

# This program is used to manage instances (create, rm, cp, mv, update)
# There is almost no error handling implemented. Please remember: this
# is a prototype, an experiment - nothing more.

import sys, os, shutil, pwd, grp, re, time, pprint
from subprocess import *

OMD_VERSION = "0.43"

# colored output, if stdout is a tty
on_tty = sys.stdout.isatty()

if on_tty:
    tty_black     = '\033[30m'
    tty_red       = '\033[31m'
    tty_green     = '\033[32m'
    tty_yellow    = '\033[33m'
    tty_blue      = '\033[34m'
    tty_magenta   = '\033[35m'
    tty_cyan      = '\033[36m'
    tty_white     = '\033[37m'
    tty_bgred     = '\033[41m'
    tty_bggreen   = '\033[42m'
    tty_bgyellow  = '\033[43m'
    tty_bgblue    = '\033[44m'
    tty_bgmagenta = '\033[45m'
    tty_bgcyan    = '\033[46m'
    tty_bgwhite   = '\033[47m'
    tty_bold      = '\033[1m'
    tty_underline = '\033[4m'
    tty_normal    = '\033[0m'
    tty_ok        = tty_green + tty_bold + 'OK' + tty_normal
    tty_error     = tty_red + tty_bold + 'ERROR' + tty_normal
else:
    tty_black     = ''
    tty_red       = ''
    tty_green     = ''
    tty_yellow    = ''
    tty_blue      = ''
    tty_magenta   = ''
    tty_cyan      = ''
    tty_white     = ''
    tty_bgred     = ''
    tty_bggreen   = ''
    tty_bgyellow  = ''
    tty_bgblue    = ''
    tty_bgmagenta = ''
    tty_bgcyan    = ''
    tty_bold      = ''
    tty_underline = ''
    tty_normal    = ''
    tty_ok        = 'OK'
    tty_error     = 'ERROR'

good = tty_bggreen + tty_white + tty_bold + "*" + tty_normal
warn = tty_bgyellow + tty_black + "?" + tty_normal
error = tty_bgred + tty_white + tty_bold + "!" + tty_normal

# Options to set via command line
opt_verbose = False
opt_interactive = False
opt_force = False

def show_success(exit_code):
    if exit_code == True or exit_code == 0:
        sys.stdout.write(tty_ok + "\n")
    else:
        sys.stdout.write(tty_error + "\n")
    return exit_code

patch_supports_merge = None
def patch_has_merge():
    # check wether our version of patch supports the option '--merge'
    global patch_supports_merge
    if patch_supports_merge == None:
	patch_supports_merge = (0 == os.system("true | patch --merge >/dev/null 2>&1"))
        if not patch_supports_merge:
	    sys.stdout.write("Your version of patch does not support --merge.\n")
    return patch_supports_merge


def have_dialog():
    return False # os.system("which dialog >/dev/null 2>&1") == 0

def run_dialog(args):
    env = {
        "TERM":os.getenv("TERM", "linux"), 
        "LANG": "de_DE.UTF-8"
    }
    p = Popen(["dialog", "--shadow"] + args, env = env, stderr = PIPE)
    response = p.stderr.read()
    return 0 == os.waitpid(p.pid, 0)[1], response
    
def dialog_menu(title, text, choices, defvalue, oktext, canceltext):
    args = [ "--ok-label", oktext, "--cancel-label", canceltext ]
    if defvalue != None:
        args += [ "--default-item", defvalue ]
    args += [ "--title", title, "--menu", text, "0", "0", "0" ] # "20", "60", "17" ]
    for text, value in choices:
        args += [ text, value ]
    return run_dialog(args)

def dialog_regex(title, text, regex, value, oktext, canceltext):
    while True:
        args = [ "--ok-label", oktext, "--cancel-label", canceltext,
                 "--title", title, "--inputbox", text, "0", "0", value ]
        change, new_value = run_dialog(args)
        if not change:
            return False, value
        elif not regex.match(new_value):
            dialog_message("Invalid value. Please try again.")
            value = new_value
        else:
            return True, new_value


def dialog_yesno(text, yeslabel = "yes", nolabel = "no"):
    state, response = run_dialog(["--yes-label", yeslabel, "--no-label", nolabel, "--yesno", text, "0", "0"])
    return state

def dialog_message(text, buttonlabel="OK"):
    run_dialog(["--ok-label", buttonlabel, "--msgbox", text, "0", "0"])

def ask_user(title, message, yes_text, no_text):
    if have_dialog():
        p = Popen(["dialog", "--title", title, "--shadow", "--yes-label", yes_text, "--no-label", no_text, "--yesno", message, "0", "0"])
	return 0 == os.waitpid(p.pid, 0)[1]
    else:
	sys.stdout.write(tty_bgblue + tty_white + tty_bold + title + tty_normal + ": ")
	sys.stdout.write(message + "\n")
	yes_answer = yes_text[0].lower()
	for no_answer in no_text.lower():
	    if yes_answer != no_answer:
	        break

	while True:
	    sys.stdout.write("   %s / %s  [%s/%s] ==> " %
	           	(yes_text, no_text, yes_answer.upper(), no_answer))
	    sys.stdout.flush()
	    a = sys.stdin.readline().strip().lower()
	    if not a or a == yes_answer:
		return True
	    elif a == no_answer:
		return False

def ask_user_choices(title, message, choices):
    if have_dialog():
        argv = [ "dialog", "--stderr", "--shadow", "--nocancel", "--title", title, "--menu", message, "16", "60", str(len(choices)) ]
	for c, t in choices:
	   argv += [ c, t ]
	choice = Popen(argv, stderr=PIPE).stderr.read()
        return choice.strip()
    else:
	sys.stdout.write(tty_bgcyan + tty_white + tty_bold + title + tty_normal + "\n")
	sys.stdout.write(message + "\n\n")
	chars = []
	for choice, title in choices:
	    sys.stdout.write("  %-10s - %s\n" % (choice, title))
	    for c in choice:
		if c.lower() not in chars:
		    chars.append(c)
		    break
	sys.stdout.write("\n")

	while True:
	    sys.stdout.write("[%s] ==> " %
		    "/".join([char for (char, (c,t)) in zip(chars, choices)]))
	    sys.stdout.flush()
	    a = sys.stdin.readline().strip().lower()
	    for char, (choice, title) in zip(chars, choices):
		if a == char:
		    return choice

def bail_out(message):
    sys.stderr.write(message)
    sys.exit(1)

def omd_root():
    return "/omd/versions/" + OMD_VERSION

# Read distro- and version specific values
def read_info():
    global g_info
    g_info = {}
    info_dir = omd_root() + "/share/omd"
    for f in os.listdir(info_dir):
	if f.endswith(".info"):
	    for line in file(info_dir + "/" + f):
	       var, value = line.split('=')
	       g_info[var.strip()] = value.strip()

def site_name():
        return pwd.getpwuid(os.getuid()).pw_name

def site_dir(sitename):
    return "/omd/sites/" + sitename

def tmp_dir(sitename):
    return "/omd/sites/%s/tmp" % sitename

# The version of a site is solely determined by the
# link ~SITE/version
def site_version(sitename):
    version_link = site_dir(sitename) + "/version"
    try:
        version = os.readlink(version_link).split("/")[-1]
        return version
    except:
        return None

def create_version_symlink(sitename, version):
    linkname = site_dir(sitename) + "/version"
    if os.path.exists(linkname):
	os.remove(linkname)
    os.symlink("../../versions/%s" % OMD_VERSION, linkname)


def site_exists(sitename):
    return os.path.exists(site_dir(sitename))

def all_sites():
    return [ s for s in os.listdir("/omd/sites") if s[0] != '.' ]

# Check if site is completely stopped
def site_is_stopped(sitename):
    return check_status(sitename, False) == 1

def site_is_running(sitename):
    return check_status(sitename, False) == 0

def groupdel(groupname):
    os.system("groupdel " + groupname)

def groupadd(groupname):
    os.system("groupadd " + groupname)

def useradd(sitename):
    # Create user for running site 'name'
    groupadd(sitename)
    useradd_options = g_info["USERADD_OPTIONS"]
    os.system("useradd %s -d '%s' -c 'OMD site %s' -g %s -G omd %s -s /bin/bash" % \
                (useradd_options, site_dir(sitename), sitename, sitename, sitename))

    # Add Apache to new group. It needs to be able to write in to the
    # command pipe and possible other stuff
    add_user_to_group(g_info["APACHE_USER"], sitename)

def add_user_to_group(user, group):
    cmd = g_info["ADD_USER_TO_GROUP"] % {"user": user, "group" : group}
    return os.system(cmd + " >/dev/null") == 0

def userdel(name):
    os.system("userdel -r " + name + " 2>/dev/null")
    # On some OSes (e.g. debian) the group is automatically removed if
    # it bears the same name as the user. So first check for the group.
    if group_exists(name):
        groupdel(name)

def user_exists(name):
    try:
	pwd.getpwnam(name)
	return True
    except:
	return False

def group_exists(name):
    try:
	grp.getgrnam(name)
	return True
    except:
	return False

def group_id(name):
    try:
	g = grp.getgrnam(name)
	return g.gr_gid
    except:
	return None

def user_logged_in(name):
    # Check, if processes of named user are existing
    return os.system("ps --no-headers --user '%s' >/dev/null 2>&1" % name) == 0

def switch_to_site_user():
    p = pwd.getpwnam(g_sitename)
    uid = p.pw_uid
    gid = p.pw_gid
    os.chdir(p.pw_dir)
    os.setgid(gid)
    os.setgroups([group_id('omd')])
    os.setuid(uid)


def clear_environment():
    # first remove *all* current environment variables
    keep = [ "TERM" ]
    for key in os.environ:
        if key not in keep: 
            os.unsetenv(key)

def set_environment():
    os.putenv("OMD_SITE", g_sitename)
    os.putenv("OMD_ROOT", g_sitedir)
    os.putenv("PATH", "%s/local/bin:%s/bin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin" %
                                                                     (g_sitedir, g_sitedir))
    os.putenv("USER", g_sitename)
    os.putenv("LD_LIBRARY_PATH", "%s/local/lib:%s/lib" % (g_sitedir, g_sitedir))
    os.putenv("HOME", g_sitedir)

    # allow user to define further environment variable in ~/etc/environment
    envfile = g_sitedir + "/etc/environment"
    if os.path.exists(envfile):
        lineno = 0
        for line in file(envfile):
            lineno += 1
            line = line.strip()
            if line == "" or line[0] == "#":
                continue # allow empty lines and comments
            parts = line.split("=")
            if len(parts) != 2:
                bail_out("%s: syntax error in line %d\n" % (envfile, lineno))
            varname = parts[0]
            value = parts[1]
            if value.startswith('"'):
                value = value.strip('"')
            if value.startswith("'"):
                value = value.strip("'")
            os.putenv(varname, value)

def hostname():
    try:
        return os.popen("hostname").read().strip()
    except:
        return "localhost"

def tmpfs_mounted(sitename):
    # Problem here: if /omd is a symbolic link somewhere else,
    # then in /proc/mounts the physical path will appear and be
    # different from tmp_path. We just check the suffix therefore.
    path_suffix = "sites/%s/tmp" % sitename
    for line in file("/proc/mounts"):
        device, mp, fstype, options, dump, fsck = line.split()
        if mp.endswith(path_suffix) and fstype == 'tmpfs':
            return True
    return False

def create_tmpfs(sitename):
    if tmpfs_mounted(sitename):
        return
    if os.getuid() == 0:
        switch_to_site_user()

    tmp = tmp_dir(sitename)
    sys.stdout.write("Creating temporary filesystem...")
    sys.stdout.flush()
    if not os.path.exists(tmp):
        os.mkdir(tmp)
    if 0 != os.system("mount '%s'" % tmp):
        sys.stdout.write(tty_error + "\n")
        return
    create_skeleton_files(sitename, "tmp")
    chown_tree(tmp, sitename)
    sys.stdout.write(tty_ok + "\n")

def unmount_tmpfs(sitename):
    if tmpfs_mounted(sitename):
        sys.stdout.write("Unmounting temporary filesystem...")
	for t in range(0, 10):
	    if 0 == os.system("umount '%s'" % tmp_dir(sitename)):
	        sys.stdout.write(tty_ok + "\n")
		return
	    sys.stdout.write(".")
	    sys.stdout.flush()
	    time.sleep(1)
        bail_out(tty_error + ": Cannot unmount tmp filesystem.\n")

def add_to_fstab(sitename):
    # tmpfs                   /opt/omd/sites/b01/tmp  tmpfs   user,uid=b01,gid=b01 0 0
    mountpoint = tmp_dir(sitename)
    sys.stdout.write("Adding %s to /etc/fstab.\n" % mountpoint)
    file("/etc/fstab", "a+").write("tmpfs  %s tmpfs noauto,user,mode=755,uid=%s,gid=%s 0 0\n" % \
        (mountpoint, sitename, sitename))

def remove_from_fstab(sitename):
    mountpoint = tmp_dir(sitename)
    sys.stdout.write("Removing %s from /etc/fstab..." % mountpoint)
    newtab = file("/etc/fstab.new", "w")
    for line in file("/etc/fstab"):
        if "uid=%s," % sitename in line and mountpoint in line:
            continue
        newtab.write(line)
    os.rename("/etc/fstab.new", "/etc/fstab")
    sys.stdout.write(tty_ok + "\n")

def start_site(sitename):
    create_tmpfs(sitename)
    call_init_scripts(sitename, "start")

def create_skeleton_files(sitename, dir):
    sitedir = site_dir(sitename)
    replacements = {
	"###SITE###" : sitename,
	"###ROOT###" : sitedir,
    }
    # Hack: exclude tmp if dir is '.'
    exclude_tmp = dir == "."
    skelroot = "/omd/versions/%s/skel" % OMD_VERSION
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk(dir):
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
	for entry in dirnames + filenames:
            if exclude_tmp:
                if dirpath == "." and entry == "tmp":
                    continue
                if dirpath == "tmp" or dirpath.startswith("tmp/"): 
                    continue
	    create_skeleton_file(skelroot, sitedir, dirpath + "/" + entry, replacements)

def delete_user_file(user_path):
    if os.path.isdir(user_path):
	shutil.rmtree(user_path)
    else:
	os.remove(user_path)


def create_skeleton_file(skelbase, userbase, relpath, replacements):
    skel_path = skelbase + "/" + relpath
    user_path = userbase + "/" + relpath

    # Remove old version, if existing (needed during update)
    if os.path.exists(user_path):
	delete_user_file(user_path)

    # Create directories, symlinks and files
    if os.path.isdir(skel_path):
	os.makedirs(user_path)
    elif os.path.islink(skel_path):
        os.symlink(os.readlink(skel_path), user_path)
    else:
	file(user_path, "w").write(replace_tags(file(skel_path).read(), replacements))

    if not os.path.islink(skel_path):
	mode = os.stat(skel_path).st_mode & 0xfff
	os.chmod(user_path, mode)


def create_apache_hook(sitename):
    file("/omd/apache/%s.conf" % sitename, "w").write("Include %s/etc/apache/mode.conf\n" % site_dir(sitename))

def delete_apache_hook(sitename):
    hook_path = "/omd/apache/%s.conf" % sitename
    if not os.path.exists(hook_path):
        return
    try:
	os.remove(hook_path)
    except Exception, e:
	sys.stderr.write("Cannot remove apache hook %s: %s\n" % (hook_path, e))

def reload_apache():
    sys.stdout.write("Reloading Apache...")
    sys.stdout.flush()
    show_success(os.system("%s reload" % g_info["APACHE_CTL"]))

def restart_apache():
    sys.stdout.write("Restarting Apache...")
    sys.stdout.flush()
    show_success(os.system("%s restart >/dev/null" % g_info["APACHE_INIT"]))

def replace_tags(content, replacements):
    for var, value in replacements.items():
        content = content.replace(var, value)
    return content

def stop_if_not_stopped(sitename):
    if not site_is_stopped(sitename):
        stop_site(sitename)

def stop_site(sitename):
    call_init_scripts(sitename, "stop")


# Change site specific information in files originally create from
# skeleton files. Skip files below tmp/
def patch_skeleton_files(old, new):
    skelroot = "/omd/versions/%s/skel" % OMD_VERSION
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk("."):
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
        targetdir = site_dir(new) + "/" + dirpath
        if targetdir.startswith(tmp_dir(new)):
            continue # Skip files below tmp
        for fn in filenames:
            src = dirpath + "/" + fn
            dst = targetdir + "/" + fn
            if os.path.isfile(src) and not os.path.islink(src) \
                and os.path.exists(dst): # not deleted by user
		try:
		    patch_template_file(src, dst, old, new)
                except Exception, e:
                    sys.stderr.write("Error patching template file '%s': %s\n" %
                            (dst, e))



def chown_tree(dir, user):
    uid = pwd.getpwnam(user).pw_uid
    gid = pwd.getpwnam(user).pw_gid
    os.chown(dir, uid, gid)
    for dirpath, dirnames, filenames in os.walk(dir):
        for entry in dirnames + filenames:
            os.lchown(dirpath + "/" + entry, uid, gid)

def instantiate_skel(path):
    t = file(path).read()
    replacements = {
        "###SITE###" : g_sitename,
        "###ROOT###" : g_sitedir,
    }
    return replace_tags(t, replacements)


def patch_template_file(src, dst, old, new):
    # Create patch from old instanciated skeleton file to new one
    content = file(src).read()
    for site in [ old, new ]:
        replacements = {
            "###SITE###" : site,
            "###ROOT###" : site_dir(site),
        }
        file("%s.skel.%s" % (dst, site), "w").write(replace_tags(content, replacements))

    # Now create patch from old to new and immediately apply on
    # existing - possibly user modified - file.
    if 0 == os.system("diff -u %s.skel.%s %s.skel.%s | patch --force --backup --forward --silent %s" %
            (dst, old, dst, new, dst)):
        # remove unnecessary files
        try:
            os.remove(dst + ".skel." + old)
            os.remove(dst + ".skel." + new)
            os.remove(dst + ".orig")
        except:
            pass
    else:
        sys.stdout.write("%s: Cannot update due to your changes. Please check.\n" % dst)


# Try to merge changes from old->new version and
# old->user version
def merge_update_file(relpath, old_version, new_version):
    fn = tty_bold + tty_bgblue + tty_white + relpath + tty_normal
    sys.stdout.write(warn + " Merging changes from %s to %s with your changes of %s...\n" %
	    (old_version, new_version, fn))

    replacements = {
        "###SITE###" : g_sitename,
        "###ROOT###" : g_sitedir,
    }
    user_path = g_sitedir + "/" + relpath
    content = file(user_path).read()
    permissions = os.stat(user_path).st_mode

    for version in [ old_version, new_version ]:
	file("%s-%s" % (user_path, version), "w").write(replace_tags(file("/omd/versions/%s/skel/%s" % (version, relpath)).read(), replacements))
    version_patch = os.popen("diff -u %s-%s %s-%s" % (user_path, old_version, user_path, new_version)).read()

    # First try to merge the changes in the version into the users' file
    merge = patch_has_merge() and "--merge" or ""
    f = os.popen("patch --force --backup --forward --silent %s %s" % (merge, user_path), "w")
    f.write(version_patch)
    status = f.close()
    if status:
	exitcode = status / 256
    else:
	exitcode = 0
    if exitcode == 0:
	sys.stdout.write("Successfully merged changes from %s -> %s into %s\n" %
		(old_version, new_version, fn))
	return

    # No success. Should we try merging the users' changes onto the new file?
    # user_patch = os.popen(
    while True:
        merge_message = patch_has_merge() and '(watch out for >>>>> and <<<<<)' or ''
        editor = os.getenv("EDITOR", "/bin/vi")
	choice = ask_user_choices("Conflicts in " + relpath + "!", "I've tried to merge the changes from version %s to %s into %s.\n"
	   "Unfortunately there are conflicts with your changes. \n"
	   "You have the following options: " %
		( old_version, new_version, relpath ),
		[ ( "diff",    "Show differences between your and the new default version" ),
		  ( "you",     "Show your changes compared with the old default version" ),
		  ( "new",     "Show what has changed from %s to %s" % (old_version, new_version) ),
		  ( "edit",    "Edit file with %s%s" % (editor, merge_message) ),
		  ( "keep",    "Keep half-merged version of the file" ),
		  ( "restore", "Restore your original version of the file" ),
		  ( "install", "Install the new default version" ),
		  ( "shell",   "Open a shell for looking around" ),
	          ( "abort",   "Stop here and abort update!" ),
		])
        if choice == "abort":
	    sys.stdout.write("Good bye.\n")
	    sys.exit(1)
	if choice == "keep":
	    break
	elif choice == "edit":
	    os.system("%s '%s'" % (editor, user_path))
	elif choice == "diff":
	    sys.stdout.write(tty_bgmagenta + tty_white)
	    sys.stdout.flush()
	    os.system("diff -u %s.orig %s-%s" % (user_path, user_path, new_version))
	    sys.stdout.write(tty_normal)
	elif choice == "you":
	    sys.stdout.write(tty_bgmagenta + tty_white)
	    sys.stdout.flush()
	    os.system("diff -u %s-%s %s.orig" % (user_path, old_version, user_path))
	    sys.stdout.write(tty_normal)
	elif choice == "new":
	    sys.stdout.write(tty_bgmagenta + tty_white)
	    sys.stdout.flush()
	    os.system("diff -u %s-%s %s-%s" % (user_path, old_version, user_path, new_version))
	    sys.stdout.write(tty_normal)
	elif choice == "shell":
	    sys.stdout.write("Starting BASH. Type CTRL-D to continue.\n")
	    thedir = "/".join(user_path.split("/")[:-1])
	    os.system("cd '%s' ; bash -i" % thedir)
	elif choice == "keep":
	    os.rename(user_path + ".orig", user_path)
            os.chmod(user_path, permissions)
	    sys.stdout.write("Restored your version.\n")
	    break
	else:
	    os.rename("%s-%s" % (user_path, new_version), user_path)
            os.chmod(user_path, permissions)
	    sys.stdout.write("Installed default file of version %s.\n" % new_version)
	    break
	sys.stdout.write("\n\n")

    for p in [ "%s-%s" % (user_path, old_version),
	       "%s-%s" % (user_path, new_version),
	       "%s.orig" % user_path ]:
	try:
	    os.remove(p)
	except:
	    pass


def filetype(p):
    # check for symlinks first. Might be dangling. In that
    # case os.path.exists checks the links target for existance
    # and reports it is non-existing.
    if os.path.islink(p):
	tp = "link"
    elif not os.path.exists(p):
	tp = None
    elif os.path.isdir(p):
	tp = "dir"
    else:
	tp = "file"
    return tp


def update_file(old_version, new_version, userdir, relpath):
#     sys.stdout.write("Updating %s | %s | %s | %s\n" %
# 		(old_skel, new_skel, userdir, relpath))
#
    old_skel = "/omd/versions/%s/skel" % old_version
    new_skel = "/omd/versions/%s/skel" % new_version

    replacements = {
	"###SITE###" : g_sitename,
	"###ROOT###" : g_sitedir,
    }

    old_path = old_skel + "/" + relpath
    new_path = new_skel + "/" + relpath
    user_path = userdir + "/" + relpath

    old_type  = filetype(old_path)
    new_type  = filetype(new_path)
    user_type = filetype(user_path)

    if old_type == "file":
	old_content = instantiate_skel(old_path)

    if user_type == "file":
	user_content = file(user_path).read()

    if new_type == "file":
	new_content = instantiate_skel(new_path)

    # compare our new version with the user's version
    type_differs = user_type != new_type
    content_differs =   (user_type == "file" \
			   and new_type == "file" \
			   and user_content != new_content) or \
		           (user_type == "link" \
			    and new_type == "link" \
			    and os.readlink(user_path) != os.readlink(new_path))
    differs = type_differs or content_differs

    # compare our old version with the user's version
    user_changed_type = old_type != user_type
    user_changed_content = (old_type == "file" \
			   and user_type == "file" \
			   and old_content != user_content) or \
		           (old_type == "link" \
			    and user_type == "link" \
			    and os.readlink(old_path) != os.readlink(user_path))
    user_changed = user_changed_type or user_changed_content

    # compare our old with our new version
    we_changed_type = old_type != new_type
    we_changed_content =   (old_type == "file" \
			   and new_type == "file" \
			   and old_content != new_content) or \
		           (old_type == "link" \
			    and new_type == "link" \
			    and os.readlink(old_path) != os.readlink(new_path))
    we_changed = we_changed_type or we_changed_content

#     if opt_verbose:
#         sys.stdout.write("%s%s%s:\n" % (tty_bold, relpath, tty_normal))
#         sys.stdout.write("  you       : %s\n" % user_type)
#         sys.stdout.write("  %-10s: %s\n" % (old_version, old_type))
#         sys.stdout.write("  %-10s: %s\n" % (new_version, new_type))

    # A --> MISSING FILES

    # Handle cases with missing files first. At least old or new are present,
    # or this function would never have been invoked.
    fn = tty_bold + tty_bgblue + tty_white + relpath + tty_normal

    # 1) New version ships new skeleton file -> simply install
    if not old_type and not user_type:
	create_skeleton_file(new_skel, userdir, relpath, replacements)
	sys.stdout.write(good + " Installed new %s %s.\n" % (new_type, fn))

    # 2) new version ships new skeleton file, but user's own file/dir/link
    #    is in the way.
    # 2a) the users file is identical with our new version
    elif not old_type and not differs:
    	sys.stdout.write(good + " Both you and new version created a new %s %s with the same content. Good.\n" %
		(new_type, fn))

    # 2b) user's file has a different content or type
    elif not old_type:
	if ask_user(relpath, "The new version ships the %s %s, "
		    "but you have created a %s in that place "
		    "yourself. Shall we keep your %s or replace "
	            "is with mine?" % (new_type, relpath, user_type, user_type), "keep", "replace"):
	    sys.stdout.write(warn + " Keeping your version of %s\n" % fn)
	else:
	    create_skeleton_file(new_skel, userdir, relpath, replacements)
	    sys.stdout.write(good + " Installing new default version of %s\n" % fn)

    # 3) old version had a file which has vanished in new (got obsolete). If the user
    #    has deleted it himself, we are just happy
    elif not new_type and not user_type:
	sys.stdout.write(good + " File %s has vanished in new version. You've deleted it also. Good.\n" % fn)

    # 3b) same, but user has not deleted and changed type
    elif not new_type and user_changed_type:
	if ask_user(relpath, "The %s %s has become obsolete in "
		    "this version, but you have changed it into a "
		    "%s. Do you want to keep your %s or "
		    "may I delete it for you, please?" % (old_type, relpath, user_type, user_type),
		    "keep", "delete"):
	    sys.stdout.write(warn + " Keeping your %s\n" % fn)
	else:
	    delete_user_file(user_path)
	    sys.stdout.write(warn + " Deleted %s\n" % fn)

    # 3c) same, but user has changed it contents
    elif not new_type and user_changed_content:
	if ask_user(relpath, "The %s %s has become obsolete in "
		    "this version, but you have changed its contents. "
		    "Do you want to keep your file or "
		    "may I delete it for you, please?" % (old_type, relpath),
		    "keep", "delete"):
	    sys.stdout.write(warn + " Keeping your %s\n" % fn)
	else:
	    delete_user_file(user_path)
	    sys.stdout.write(warn + " Deleted %s\n" % fn)

    # 3d) same, but user hasn't changed anything -> silently delete
    elif not new_type:
	delete_user_file(user_path)
	sys.stdout.write(good + " File %s has vanished in new version, unchanged by you. Deleting.\n" % fn)

    # 4) old and new exist, but user file not. User has deleted that
    #    file. We simply do nothing in that case. The user surely has
    #    a good reason why he deleted the file.
    elif not user_type and not we_changed:
        sys.stdout.write(good + " You've deleted %s, which has not changed in new version. Ignoring it.\n" % fn)

    # 4b) File changed in new version. Simply warn.
    elif not user_type:
	sys.stdout.write(warn + " File %s has changed in new version, you've deleted it anyway. Ignoring.\n" % fn)

    # B ---> UNCHANGED, EASY CASES

    # 5) New version didn't change anything -> no need to update
    elif not we_changed:
	pass

    # 6) User didn't change anything -> take over new version
    elif not user_changed:
	create_skeleton_file(new_skel, userdir, relpath, replacements)
	sys.stdout.write(good + " Installed new version of %s.\n" % fn)

    # 7) User changed, but accidentally exactly as we did -> no action neccessary
    elif not differs:
	sys.stdout.write(good + " You've changed %s exactly as in the new version. Keeping.\n" % fn)

    # TEST UNTIL HERE

    # C ---> PATCH DAY, HANDLE FILES
    # 7) old, new and user are files. And all are different
    elif old_type == "file" and new_type == "file" and user_type == "file":
	merge_update_file(relpath, old_version, new_version)

    # D ---> SYMLINKS
    # 8) all are symlinks, all changed
    elif old_type == "link" and new_type == "link" and user_type == "link":
	if ask_user(relpath, "'%s' is a symlink that pointed to "
		"%s in the old version and to "
		"%s in the new version. But meanwhile you "
		"changed to link target to %s. "
		"Shall I keep your link or replace it with "
		"the new default target?" %
		(relpath, os.readlink(old_path), os.readlink(new_path), os.readlink(user_path)),
		"keep", "replace"):
	    sys.stdout.write(warn + " Keeping your link %s\n" % fn)
	else:
	    os.remove(user_path)
	    os.symlink(os.readlink(new_path), user_path)
	    sys.stdout.write(warn + " Set link %s to new target %s\n" % (fn, os.readline(new_path)))

    # E ---> FILE TYPE HAS CHANGED (NASTY)
    # Now we have to handle cases, where the file types of the three
    # versions are not identical and at the same type the user or
    # have changed the third file to. We cannot merge here, the user
    # has to decide wether to keep his version of use ours.

    # 9) We have changed to file type
    elif old_type != new_type:
	if ask_user(relpath, "The %s %s has changed into a %s in "
		"the new version. Meanwhile you have changed "
		"the %s of your copy of that %s. "
		"Do you want to keep your version or use "
		"the new default? " %
		(old_type, relpath, new_type, user_changed_type and "type" or "content",
		 old_type),
		"keep", "use new"):
	    sys.stdout.write(warn + " Keeping your version of %s" % fn)
	else:
	    create_skeleton_file(new_skel, userdir, relpath, replacements)
	    sys.stdout.write(warn + " Replaced your %s %s by new default %s.\n" % (user_type, relpath, new_type))

    # 10) The user has changed the file type, we just the content
    elif old_type != user_type:
	if ask_user(relpath, "Usually %s is a %s in both the "
		"old and new version. But you have changed it "
		"into a %s. Do you want to keep that of may "
		"I replace your %s with the new default "
		"%s, please?" % 
		(relpath, old_type, user_type, new_type),
		"keep", "replace"):
	    sys.stdout.write(warn + " Keeping your %s %s.\n" % (user_type, fn))
	else:
	    create_skeleton_file(new_skel, userdir, relpath, replacements)
	    sys.stdout.warn(warn + " Delete your %s and created new default %s %s.\n" % (user_type, new_type, fn))

    # 11) This case should never happen, if I've not lost something
    else:
	if ask_user(relpath, "You somehow fiddled along with "
	       "%s, and I do not have the "
	       "slightest idea what's going on here. May "
	       "I please install the new default %s "
	       "here, or do you want to keep your %s?" %
	       (relpath, new_type, user_type),
	       "keep", "install new"):
	    sys.stdout.write(warn + " Keeping your %s %s.\n" % (user_type, fn))
	else:
	    create_skeleton_file(new_skel, userdir, relpath, replacements)
	    sys.stdout.warn(warn + " Delete your %s and created new default %s %s.\n" % (user_type, new_type, fn))

def init_scripts(sitename):
    rc_dir = "/omd/sites/%s/etc/rc.d" % sitename
    try:
        scripts = os.listdir(rc_dir)
        scripts.sort()
        return rc_dir, scripts
    except:
        return rc_dir, []

def call_init_scripts(sitename, command):
    # Restart: Do not restart each service after another,
    # but first do stop all, then start all again! This
    # preserves the order.
    if command == "restart":
        call_init_scripts(sitename, "stop")
        call_init_scripts(sitename, "start")
        return

    # Call stop scripts in reverse order
    rc_dir, scripts = init_scripts(sitename)
    if command == "stop":
        scripts.reverse()
    ok = True
    for script in scripts:
        if 0 != os.system("%s/%s %s" % (rc_dir, script, command)):
            ok = False
    if ok:
         return 0
    else:
         return 2

def check_status(sitename, display=True):
    if display:
        sys.stdout.write("%s: " % sitename)
        sys.stdout.flush()
    num_running = 0
    num_unused = 0
    rc_dir, scripts = init_scripts(sitename)
    for script in scripts:
        komponent = script.split("/")[-1].split('-')[-1]
        if display:
            sys.stdout.write(" %s:" % komponent)
        state = os.system("%s/%s status >/dev/null 2>&1" % (rc_dir, script)) >> 8
        if display:
            sys.stdout.write(tty_bold)
        if state == 0:
            if display:
                sys.stdout.write(tty_green + "running")
            num_running += 1
        elif state == 5:
            if display:
                sys.stdout.write(tty_blue + "unused")
            num_unused += 1
        else:
            if display:
                sys.stdout.write(tty_red + "stopped")
        if display:
            sys.stdout.write(tty_normal)
    if display:
        sys.stdout.write("\n")

    if num_running == 0:
        return 1 # completely stopped
    elif num_running + num_unused == len(scripts):
        return 0 # all running
    else:
        return 2 # partially running


def config_load():
    confpath = g_sitedir + "/etc/omd/site.conf"
    if not os.path.exists(confpath):
        return

    for line in file(confpath):
	line = line.strip()
	if line == "" or line[0] == "#":
	    continue
	var, value = line.split("=", 1)
	value = value.strip('"').strip("'")
	var = var.strip()
        if not var.startswith("CONFIG_"):
            sys.stderr.write("Ignoring invalid variable %s.\n" % var)
        else:
            var = var[7:]
            if var in g_hooks:
                g_hooks[var]["value"] = value

def config_save():
    confdir = g_sitedir + "/etc/omd"
    if not os.path.exists(confdir):
        os.mkdir(confdir)
    f = file(g_sitedir + "/etc/omd/site.conf", "w")
    hooknames = g_hooks.keys()
    hooknames.sort()
    for hookname in hooknames:
        hook = g_hooks[hookname]
	f.write("CONFIG_%s='%s'\n" % (hookname, hook["value"]))

# Get information about all hooks
def config_load_hooks():
    global g_hooks
    g_hooks = {}
    hook_dir = g_sitedir + "/lib/omd/hooks"
    for hookname in os.listdir(hook_dir):
	if hookname[0] != '.':
            hook = config_load_hook(hookname)
            # only load configuration hooks
            if hook.get("choices", None) != None:
                g_hooks[hookname] = hook
    # now load actual values from site.conf, if available
    config_load()

def refresh_hooks():
    config_load_hooks()
    config_set_all() # execute 'set' functions with current values
    config_save()

def call_hook(hookname, args):
    hook_file = g_sitedir + "/lib/omd/hooks/" + hookname
    argsstring = " ".join([ "'%s'" % arg for arg in args ])
    os.putenv("OMD_ROOT", g_sitedir)
    os.putenv("OMD_SITE", g_sitename)
    return os.popen(hook_file + " " + argsstring).read().strip()

def config_load_hook(hookname):

    def get_hook_info(info):
	return call_hook(hookname, [info])

    hook = { "name" : hookname }
    hook["alias"] = get_hook_info("alias")
    hook["description"] = get_hook_info("description")
    hook["default"] = get_hook_info("default")
    hook["value"] = hook["default"]
    # The choices can either be a list of possible keys. Then
    # the hook outputs one live for each choice where the key and a
    # description are separated by a colon. Or it outputs one line
    # where that line is an extended regular expression matching the
    # possible values.
    choicestxt = get_hook_info("choices").split("\n")
    if len(choicestxt) == 1:
        regextext = choicestxt[0].strip()
        if regextext != "":
            choices = re.compile(regextext + "$")
        else:
            choices = None
    else:
        choices = []
        try:
            for line in choicestxt:
                val, descr = line.split(":", 1)
                val = val.strip()
                descr = descr.strip()
                choices.append( (val, descr) )
        except:
            sys.stderr.write("Invalid output of hook: %s\n" % choicestxt)
            sys.exit(1)

    hook["choices"] = choices
    return hook


def config_set(args):
    if len(args) != 2:
	sys.stderr.write("Please specify variable name and value\n")
	config_usage()
	return

    if not site_is_stopped(g_sitename):
        sys.stderr.write("Cannot change config variables while site is running.\n")
        return

    hookname = args[0]
    value = args[1]
    hook = g_hooks.get(hookname)
    if not hook:
	sys.stderr.write("No such variable '%s'\n" % hookname)
	return

    # Check if value is valid. Choices are either a list of allowed
    # keys or a regular expression
    if type(hook["choices"]) == list:
        choices = [ var for (var, descr) in hook["choices"] ]
        if value not in choices:
            sys.stderr.write("Invalid value for '%s'. Allowed are: %s\n" % \
                    (value, ", ".join(choices)))
            return
    else:
        if not hook["choices"].match(value):
            sys.stderr.write("Invalid value for '%s'. Does not match allowed pattern.\n" % value)
            return

    config_set_value(hookname, value)

def config_set_all():
    for hookname, hook in g_hooks.items():
        config_set_value(hookname, hook["value"])

def config_set_value(hookname, value):
    hook = g_hooks.get(hookname)

    # Call hook with 'set'. If it outputs something, that will
    # be our new value (i.e. hook disagrees with the new setting!)
    answer = os.popen("%s/lib/omd/hooks/%s set '%s'" % (g_sitedir, hookname, value)).read()
    if len(answer) > 0:
        value = answer.strip()

    hook["value"] = value
    config_save()

def config_usage():
    sys.stdout.write("""Usage of config command:

omd config               - interactive configuration menu
omd config show          - show current settings of all configuration variables
omd config show VAR      - show current setting of variable VAR
omd config set VAR VALUE - set VAR to VALUE
""")

def config_show(args):
    if len(args) == 0:
	hooknames = g_hooks.keys()
	hooknames.sort()
	for hookname in hooknames:
	    sys.stdout.write("%s: %s\n" % (hookname, g_hooks[hookname]["value"]))
    else:
        output = []
        for hookname in args:
            hook = g_hooks.get(hookname)
            if not hook:
                sys.stderr.write("No such variable %s\n" % hookname)
            else:
                output.append(hook["value"])
	sys.stdout.write(" ".join(output))
	sys.stdout.write("\n")

def config_configure():
    hooknames = g_hooks.keys()
    hooknames.sort()
    current_hookname = ""
    while True:
        choices = []
        for hookname in hooknames:
            hook = g_hooks[hookname]
            choices.append((hookname, hook["value"]))
        change, current_hookname = \
            dialog_menu("Configuration of site %s" % g_sitename,
                "Interactive setting of site configuration variables. You "
                "can change values only while the site is stopped.",
                choices,
                current_hookname,
                "Change",
                "Exit")
        if not change:
            return

        config_configure_hook(current_hookname)

def config_configure_hook(hookname):
    if not site_is_stopped(g_sitename):
        if not dialog_yesno("You cannot change configuration value while the "
                "site is running. Do you want me to stop the site now?"):
            return
        stop_site(g_sitename)
        dialog_message("The site has been stopped.")

    hook = g_hooks[hookname] 
    title = hook["alias"]
    descr = hook["description"].replace("\n", " ")
    value = hook["value"]
    choices = hook["choices"]
    if type(choices) == list:
        dialog_function = dialog_menu
    else:
        dialog_function = dialog_regex
    change, new_value = \
        dialog_function(title, descr, choices, value, "Change", "Cancel")
    if change:
        config_set_value(hook["name"], new_value)

def init_action(command):
    if command == "start":
        create_tmpfs(g_sitename)
    if command == "status":
        return check_status(g_sitename)
    else:
        return call_init_scripts(g_sitename, command)

# ----------------------------------------------------------
#                                                  _
#     ___ ___  _ __ ___  _ __ ___   __ _ _ __   __| |___
#    / __/ _ \| '_ ` _ \| '_ ` _ \ / _` | '_ \ / _` / __|
#   | (_| (_) | | | | | | | | | | | (_| | | | | (_| \__ \
#    \___\___/|_| |_| |_|_| |_| |_|\__,_|_| |_|\__,_|___/
#
# ----------------------------------------------------------
def main_help(args=[], options={}):
    am_root = os.getuid() == 0
    if am_root:
        sys.stdout.write("Usage (called as root):\n\n")
    else:
        sys.stdout.write("Usage (called as site user):\n\n")

    for command, only_root, needs_site, site_must_exist, confirm, synopsis, command_function, descr, confirm_text in commands:
        if only_root and not am_root:
            continue
        if am_root:
            if needs_site == 2:
                synopsis = "[SITE] " + synopsis
            elif needs_site == 1:
                synopsis = "SITE " + synopsis

        sys.stdout.write(" omd %-10s %-16s %s\n" % (command, synopsis, descr))

def main_setup(args, options={}):
    packages = g_info["OS_PACKAGES"].split()
    install_cmd = g_info["PACKAGE_INSTALL"]
    command = "%s %s" % (install_cmd, " ".join(packages))
    sys.stdout.write("Going to execute '%s'\n" % command)
    if 0 == os.system(command):
        sys.stdout.write(tty_ok + "\n")

    # Enable Apache modules
    for mod in [ "proxy", "proxy_http" ]:
        command = g_info["APACHE_ENMOD"] % mod
        if 0 != os.system(command):
            sys.stdout.write("ERROR: Could not enable Apache module mod_%s\n" % mod)

    # Activate init script of OMD and APACHE
    for service in [ 'omd',  g_info["APACHE_INIT"].split('/')[-1] ]:
        sys.stdout.write("Activating init script for \"%s\"\n" % service)
        command = g_info["ACTIVATE_INITSCRIPT"].replace("%s", service)
        sys.stdout.write("Going to execute '%s'\n" % command)
        if 0 != os.system(command):
            sys.stdout.write("ERROR\n")

    # Create group 'omd'
    if not group_exists('omd'):
        sys.stdout.write("Creating new group 'omd'\n")
        groupadd('omd')

    # set SUID bit for certain plugins (neccessary for
    # non RPM/DEB installations (FIXME: find a more elegant
    # solution later)
    for plugin in [ 'check_icmp', 'check_dhcp' ]:
        path = "/omd/versions/%s/lib/nagios/plugins/%s" % (OMD_VERSION, plugin)
        os.system("chgrp omd '%s'" % path)
        os.system("chmod 4750 '%s'" % path)


def main_uninstall(args, options={}):
    global g_sitename
    global g_sitedir
    for sitename in all_sites():
	g_sitename = sitename
        g_sitedir = site_dir(g_sitename)
	main_rm([])

    for path in [ g_info["OMD_PHYSICAL_BASE"],
		  "/omd",
		  g_info["APACHE_CONF_DIR"] + "/zzz_omd.conf",
		  "/etc/init.d/omd",
		  "/usr/bin/omd" ]:
	os.system("rm -rf '%s'" % path)

    groupdel('omd')

    sys.stdout.write("Good bye.\n")


def main_version(args, options={}):
    sys.stdout.write("OMD - OpenSource Monitoring Distribution Version %s\n" % g_info["OMD_VERSION"])

def main_versions(args, options={}):
    for version in os.listdir("/omd/versions"):
	if version != "default":
	    sys.stdout.write("%s\n" % version)

def main_sites(args, options={}):
    if on_tty:
	sys.stdout.write("SITE             VERSION\n")
    for site in all_sites():
	sys.stdout.write("%-16s %s\n" % (site, site_version(site)))

def main_create(args, options={}):
    # Make sanity checks before starting any action
    if site_exists(g_sitename):
        bail_out("Site '%s' already existing.\n" % g_sitename)
    if group_exists(g_sitename):
        bail_out("Group '%s' already existing.\n" % g_sitename)
    if user_exists(g_sitename):
        bail_out("User '%s' already existing.\n" % g_sitename)
    if not re.match("^[a-zA-Z_][a-zA-Z_0-9]{0,15}$", g_sitename):
	bail_out("Invalid site name. Must begin with a character, may contain characters, digits and _ and have length 1 up to 16\n")


    # Create operating system user for site
    useradd(g_sitename)

    sitedir = site_dir(g_sitename)
    os.makedirs(sitedir)
    os.system("chown %s:%s '%s'" % (g_sitename, g_sitename, sitedir))
    add_to_fstab(g_sitename)

    # Create symbolic link to version
    create_version_symlink(g_sitename, OMD_VERSION)

    # Build up directory structure with symbolic links relative to
    # the version link we just create
    for d in [ 'bin', 'include', 'lib', 'share' ]:
        os.symlink("version/" + d, sitedir + "/" + d)

    # Create skeleton files of non-tmp directories
    create_skeleton_files(g_sitename, '.')

    # Create site.conf with default values
    config_load_hooks()
    config_set_all() # execute 'set' functions with default values
    config_save()

    # Change ownership of all files and dirs to site user
    os.system("chown -R %s:%s '%s'" % (g_sitename, g_sitename, sitedir))

    # Create include-hook for Apache and reload apache
    create_apache_hook(g_sitename)
    sys.stdout.write("Created new site %s with version %s.\n" % (g_sitename, OMD_VERSION))
    restart_apache()

    # Mount and create contents of tmpfs. This must be done as normal
    # user. We also could do this at 'omd start', but this might confuse
    # users. They could create files below tmp which would be shadowed
    # by the mount.
    create_tmpfs(g_sitename)

    sys.stdout.write("Successfully created site %s.\n\n" % g_sitename)
    sys.stdout.write("  The site can be started with %somd start %s%s.\n" % 
            (tty_bold, g_sitename, tty_normal))
    sys.stdout.write("  The default web UI is available at %shttp://%s/%s/%s\n" % 
            (tty_bold, hostname(), g_sitename, tty_normal))
    sys.stdout.write("  The admin user for the web applications is %somdadmin%s with password %somd%s.\n" % (tty_bold, tty_normal, tty_bold, tty_normal))
    sys.stdout.write("  Please do a %ssu - %s%s for administration of this site.\n" % 
            (tty_bold, g_sitename, tty_normal))
    sys.stdout.write("\n")



def main_rm(args, options={}):
    stop_if_not_stopped(g_sitename)
    if user_logged_in(g_sitename):
        bail_out("User '%s' still logged in or running processes.\n" % g_sitename)
    unmount_tmpfs(g_sitename)

    remove_from_fstab(g_sitename)
    sys.stdout.write("Deleting user and group %s..." % g_sitename)
    userdel(g_sitename)
    sys.stdout.write(tty_ok + "\n")

    if os.path.exists(g_sitedir): # should be done by userdel
        sys.stdout.write("Deleting all data (%s)..." % g_sitedir)
        shutil.rmtree(site_dir(g_sitename))
        sys.stdout.write(tty_ok + "\n")

    # remove include-hook for Apache and tell apache
    delete_apache_hook(g_sitename)
    restart_apache()

def main_mv(args, options={}):
    global g_sitename
    global g_sitedir
    if len(args) != 1:
	bail_out("omd: Usage: omd mv oldname newname\n")
    new = args[0]
    
    if site_exists(new):
        bail_out("Site %s already existing.\n" % new)

    old = g_sitename
    if site_is_running(old):
	bail_out("Cannot rename site '%s' while it is running.\n" % old)

    unmount_tmpfs(old)
    remove_from_fstab(old)
    sys.stdout.write("Renaming site %s to %s..." % (old, new))
    sys.stdout.flush()

    # Rename base directory and apache config
    os.rename(site_dir(old), site_dir(new))
    delete_apache_hook(old)
    create_apache_hook(new)

    # Now reflect name change in configuration files which have been
    # create from skeletons. We are only interested in plain files,
    # directories and symlinks won't change.
    patch_skeleton_files(old, new)

    # Create new user and own over all files to him. Then delete old user
    useradd(new)
    chown_tree(site_dir(new), new)
    userdel(old)

    sys.stdout.write(tty_ok + "\n")

    g_sitename = new
    g_sitedir = site_dir(new)
    refresh_hooks()

    add_to_fstab(new)

    # Tell Apache about changes (need real restart, group changed)
    restart_apache()

def main_cp(args, options={}):
    global g_sitename
    global g_sitedir

    if len(args) != 1:
	bail_out("omd: Usage: omd cp oldname newname\n")
    new = args[0]
    
    if site_exists(new):
        bail_out("Site %s already existing.\n" % new)

    old = g_sitename
    if site_is_running(old):
	bail_out("Cannot copy while site '%s' is still running.\n" % old)

    sys.stdout.write("Creating new site %s as a copy of %s..." % (new, g_sitename))
    sys.stdout.flush()
    # First make exact file-per-file copy with same
    # user but already new name
    os.mkdir(site_dir(new))
    os.system("rsync -arx '%s/' '%s/'" % (site_dir(g_sitename), site_dir(new)))
    # os.system("tar cf - -C '%s' --exclude tmp . | tar xf - -C '%s'" % \
    #         (site_dir(g_sitename), site_dir(new)))

    # Change config files from old to new site (see rename_site())
    patch_skeleton_files(g_sitename, new)

    # Create new user and own over all files to him.
    useradd(new)
    chown_tree(site_dir(new), new)
    sys.stdout.write("OK\n")

    g_sitename = new
    g_sitedir = site_dir(new)
    refresh_hooks()

    # Entry for tmps in /etc/fstab
    add_to_fstab(new)

    # Apache hook, restart apache (group changed)
    create_apache_hook(new)
    restart_apache()

def main_update(args, options={}):
    if site_is_running(g_sitename):
	bail_out("Cannot update site '%s' while it is running.\n" % g_sitename)
    
    # Unmount tmp. We need to recreate the files and directories
    # from the new version after updating.
    unmount_tmpfs(g_sitename)

    # Target version: ourselves
    from_version = site_version(g_sitename)
    to_version = OMD_VERSION
    if from_version == to_version:
	bail_out("Site '%s' already has version %s.\n" % (g_sitename, to_version))	
    sys.stdout.write("Updating site '%s' from version %s to %s...\n" % 
	    (g_sitename, from_version, to_version))

    # Now apply changes of skeleton files. This can be done
    # in two ways: 
    # 1. creating a patch from the old default files to the new
    #    default files and applying that to the current files
    # 2. creating a patch from the old default files to the current
    #    files and applying that to the new default files
    # We implement the first method.

    from_skelroot = "/omd/versions/%s/skel" % from_version
    to_skelroot = "/omd/versions/%s/skel" % to_version
    tmp = tmp_dir(g_sitename)

    handled_paths = set([])
    # First walk through skeleton files of new version
    os.chdir(to_skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk("."): 
        if dirpath.startswith("./"): 
            dirpath = dirpath[2:]
	if dirpath.startswith("tmp"):
	    continue

	for entry in dirnames + filenames:
	    path = dirpath + "/" + entry
            if path.startswith("./"):
                path = path[2:]
	    handled_paths.add(path)
	    try:
		update_file(from_version, to_version, g_sitedir, path)
	    except Exception, e:
		sys.stderr.write("Error updating %s/%s: %s\n" % (g_sitedir, path, e))	
		raise

    # Now handle files present in old but not in new skel files
    os.chdir(from_skelroot)
    for dirpath, dirnames, filenames in os.walk("."): 
        if dirpath.startswith("./"): 
            dirpath = dirpath[2:]
	if dirpath.startswith("tmp"):
	    continue

	for entry in dirnames + filenames:
	    path = dirpath + "/" + entry
            if path.startswith("./"):
                path = path[2:]
	    if path in handled_paths:
		continue

	    # handle only files not already handled while scanning to_skelroot
	    if not os.path.exists(to_skelroot + "/" + entry):
		try:
		    update_file(from_version, to_version, g_sitedir, path)
		except Exception, e:
		    sys.stderr.write("Error updating %s/%s: %s\n" % (g_sitedir, path, e))	
		    raise

    # Change symbolic link pointing to new version
    create_version_symlink(g_sitename, to_version)

    # Let hooks do their work and update configuration
    refresh_hooks()



def main_init_action(command, args, options={}):
    global g_sitename
    global g_sitedir
    only_version = options.get("version")

    # if no site is selected, all sites are affected
    if not g_sitename:
        exit_status = 0
	for site in all_sites():
            if only_version and site_version(site) != only_version:
                continue
            # We need to do an os.system(), because each
            # site must be started with the account of the
            # site user. And after setuid() we cannot return.
            if command in [ "start", "restart", "reload" ]:
                g_sitename = site
                g_sitedir = site_dir(g_sitename)
                config_load_hooks()
                if g_hooks["AUTOSTART"]["value"] != "on":
                    sys.stdout.write("Ignoring site '%s': AUTOSTART != on\n" % site)
                    continue
            
            sys.stdout.write("%sDoing '%s' on site %s:%s\n" % (tty_bold, command, site, tty_normal))
            exit_status = max(exit_status, os.system("%s %s %s %s" % (sys.argv[0], command, site, " ".join(args))))
    else:
	exit_status = init_action(command)
    sys.exit(exit_status)

def main_config(args, options={}):
    config_load_hooks()
    if len(args) == 0:
        config_configure()
    else:
        command = args[0]
        args = args[1:]
        if command == "show":
            config_show(args)
        elif command == "set":
            config_set(args)
        else:
            config_usage()


commands = [
#  command   only_root  needs_site must_exist confirm args, function, 
#  options_spec
#  description, 
#  confirm_text
  ( "help",      False, 0, 0, False, "",        main_help,
    [],
    "Show general help",
    ""),

  ( "setup",     True,  0, 0, True, "",        main_setup,
    [],
    "Prepare operating system for OMD (installs packages)",
    "We will install missing packages from your operating system and setup the\n"
    "system apache daemon (add configuration files and modules needed by omd)\n"),

  ( "uninstall", True,  0, 0, True, "",        main_uninstall,
    [],
    "Remove OMD and all sites!",

    "BE WARNED: You are about to remove everything your system\n"
    "           have ever known about omd."),

  ( "version",   False, 0, 0, False, "",        main_version,
    [],
    "Show version of OMD",
    ""),

  ( "versions",  False, 0, 0, False, "",        main_versions,
    [],
    "List installed OMD versions",
    ""),

  ( "sites",     False, 0, 0, False, "", main_sites,
    [],
    "Show list of sites",
    ""),

  ( "create",    True,  1, 0, False, "",        main_create,
    [],
    "Create a new site",

    "This command performs the following actions on your system:\n"
    "- Create the system user <SITENAME>\n"
    "- Create the system group <SITENAME>\n"
    "- Create and populate the site home directory\n"
    "- Restart the system wide apache daemon\n"
    "- Add tmpfs for the site to fstab and mount it"),

  ( "rm",        True,  1, 1, True, "",        main_rm,
    [],
    "Remove a site (and its data)",

    "PLEASE NOTE: This action removes all configuration files\n"
    "             and variable data of the site.\n"
    "\n"
    "In detail the following steps will be done:\n"
    "- Stop all processes of the site\n"
    "- Unmount tmpfs of the site\n"
    "- Remove tmpfs of the site from fstab\n"
    "- Remove the system user <SITENAME>\n"
    "- Remove the system group <SITENAME>\n"
    "- Remove the site home directory\n"
    "- Restart the system wide apache daemon\n"),

  ( "mv",        True,  1, 1, False, "NEWNAME", main_mv,
    [],
    "Rename a site",
    ""),

  ( "cp",        True,  1, 1, False, "NEWNAME", main_cp,
    [],
    "Make a copy of a site",
    ""),

  ( "update",    False, 1, 1, False, "", main_update,
    [],
    "Update site to version " + OMD_VERSION,
    ""),

  ( "start",     False, 2, 1, False, "", lambda args, opts: main_init_action("start", args, opts),
    [ ( "version", "V", True ) ],
    "Start services of one or all sites",
    ""),

  ( "stop",      False, 2, 1, False, "", lambda args, opts: main_init_action("stop", args, opts),
    [ ( "version", "V", True ) ],
    "Stop services of site(s)",
    ""),

  ( "restart",   False, 2, 1, False, "", lambda args, opts: main_init_action("restart", args, opts),
    [ ( "version", "V", True ) ],
    "Restart services of site(s)",
    ""),

  ( "reload",    False, 2, 1, False, "", lambda args, opts: main_init_action("reload", args, opts),
    [ ( "version", "V", True ) ],
    "Reload services of site(s)",
    ""),

  ( "status",    False, 2, 1, False, "", lambda args, opts: main_init_action("status", args, opts),
    [ ( "version", "V", True ) ],
    "Show status of services of site(s)",
    ""),

  ( "config",    False, 1, 1, False, "...", main_config,
    "Show and set site configuration parameters",
    ""),
]

def handle_global_option(opt, orig):
    def opt_arg():
        global main_args
        if len(main_args) < 1:
            bail_out("Option %s needs an argument.\n" % opt)
        arg = main_args[0]
        main_args = main_args[1:]
        return arg

    if opt in [ 'V', 'version' ]:
        # Switch to other version of bin/omd
        version = opt_arg()
        if version != OMD_VERSION:
            omd_path = "/omd/versions/%s/bin/omd" % version
            if not os.path.exists(omd_path):
                bail_out("OMD version '%s' is not installed.\n" % version)
            os.execv(omd_path, sys.argv)
            bail_out("Cannot execute %s.\n" % omd_path)
    elif opt in [ 'f', 'force' ]:
        opt_force = True
        opt_interactive = False
    elif opt in [ 'i', 'interactive' ]:
        opt_force = False
        opt_interactive = True
    elif opt in [ 'v', 'verbose' ]:
        global opt_verbose
        opt_verbose = True
    else:
        sys.stdout.write("Invalid global option %s.\n" % orig)
        sys.stdout.write("Call omd help for available options.\n")
        sys.exit(1)

def parse_command_options(args, options_spec):
    options = {}
    while len(args) >= 1 and args[0][0] == '-':
        opt = args[0]
        args = args[1:]
        entries = []
        if opt.startswith("--"):
            for e in options_spec:
                if e[0] == opt[2:]:
                    entries = [e]
        else:
            for char in opt:
                for e in options_spec:
                    if e[1] == char:
                        entries.append(e)

        if len(entries) == 0:
            bail_out("Invalid option '%s'\n" % opt)

        for llong, sshort, needs_arg in entries:
            arg = None
            if needs_arg:
                if len(args) == 0:
                    bail_out("Option '%s' needs an argument.\n" % opt)
                arg = args[0]
                args = args[1:]
            options[llong] = arg
    return (args, options)



# ----------------------------------------------------------
#                                _       
#                _ __ ___   __ _(_)_ __  
#               | '_ ` _ \ / _` | | '_ \ 
#               | | | | | | (_| | | | | |
#               |_| |_| |_|\__,_|_|_| |_|
#
# ----------------------------------------------------------

# Handle global options. We might convert this to getopt
# later. But a problem here is that we have options appearing
# *before* the command and command specific ones. We handle
# the options before the command here only

main_args = sys.argv[1:]

while len(main_args) >= 1 and main_args[0].startswith("-"):
    opt = main_args[0]
    main_args = main_args[1:]
    if opt.startswith("--"):
        handle_global_option(opt[2:], opt)
    else:
        for c in opt[1:]:
            handle_global_option(c, opt)

if len(main_args) < 1:
    main_help()
    sys.exit(1)

command = main_args[0]
args = main_args[1:]
found = False
for c, only_root, needs_site, site_must_exist, confirm, argumentlist, command_function, option_spec, description, confirm_text in commands:
    if c == command:
        found = True
	break

if not found:
    bail_out("omd: no such command: %s\n" % command)

if os.getuid() != 0 and only_root:
    bail_out("omd: root permissions are needed for this command.\n")

# Parse command options. We need to do this now in order to know,
# if a site name has been specified or not
args, command_options = parse_command_options(args, option_spec) 

# Some commands need a site to be specified. If we are
# called as root, this must be done explicitely. If we
# are site user, the site name is our user name
g_sitename = None
if needs_site > 0:
    if os.getuid() == 0:
	if len(args) >= 1:
	    g_sitename = args[0]
	    args = args[1:]
        elif needs_site == 1:
	    bail_out("omd: please specify site.\n")
    else:
        g_sitename = site_name()

if g_sitename != None and site_must_exist and not site_exists(g_sitename):
    bail_out("omd: no such site: %s\n" % g_sitename)

# Commands operating on an existing site *must* run omd in
# the same version as the site has! Sole exception: update.
# That command must be run in the target version
if g_sitename and site_must_exist and command != "update":
    v = site_version(g_sitename)
    if OMD_VERSION != v:
        # Rerun with omd of correct version
        omd_path = "/omd/versions/%s/bin/omd" % v
        if os.path.exists(omd_path):
            os.execv(omd_path, sys.argv)
	    bail_out("Cannot run bin/omd of version %s.\n" % v)
        else:
            bail_out("Site %s uses version %s which is not installed.\n" 
                    "Please reinstall that version and retry this command.\n" % 
                    (g_sitename, v))


if g_sitename:
    g_sitedir = site_dir(g_sitename)
else:
    g_sitedir = None

read_info()

# Commands which affect a site and can be called as root *or* as
# site user should always run with site user priviledges. That way
# we are sure that new files and processes are created under the
# site user and never as root.
if g_sitename and os.getuid() == 0 and not only_root:
    switch_to_site_user()

# Make sure environment is in a defined state
if g_sitename:
    clear_environment()
    set_environment()

if confirm:
    sys.stdout.write("%s (yes/NO): " % confirm_text)
    sys.stdout.flush()
    a = sys.stdin.readline().strip()
    if a.lower() != "yes":
	sys.exit(0)

command_function(args, command_options)
