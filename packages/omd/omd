#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4
#
#       U  ___ u  __  __   ____
#        \/"_ \/U|' \/ '|u|  _"\
#        | | | |\| |\/| |/| | | |
#    .-,_| |_| | | |  | |U| |_| |\
#     \_)-\___/  |_|  |_| |____/ u
#          \\   <<,-,,-.   |||_
#         (__)   (./  \.) (__)_)
#
# This file is part of OMD - The Open Monitoring Distribution.
# The official homepage is at <http://omdistro.org>.
#
# OMD  is  free software;  you  can  redistribute it  and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the  Free Software  Foundation  in  version 2.  OMD  is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

import sys, os, shutil, pwd, grp, re, time, pprint, tty, termios
from subprocess import *

OMD_VERSION = "0.49"

# colored output, if stdout is a tty
on_tty = sys.stdout.isatty()

if on_tty:
    tty_black     = '\033[30m'
    tty_red       = '\033[31m'
    tty_green     = '\033[32m'
    tty_yellow    = '\033[33m'
    tty_blue      = '\033[34m'
    tty_magenta   = '\033[35m'
    tty_cyan      = '\033[36m'
    tty_white     = '\033[37m'
    tty_bgblack   = '\033[40m'
    tty_bgred     = '\033[41m'
    tty_bggreen   = '\033[42m'
    tty_bgyellow  = '\033[43m'
    tty_bgblue    = '\033[44m'
    tty_bgmagenta = '\033[45m'
    tty_bgcyan    = '\033[46m'
    tty_bgwhite   = '\033[47m'
    tty_bold      = '\033[1m'
    tty_underline = '\033[4m'
    tty_normal    = '\033[0m'
    tty_ok        = tty_green + tty_bold + 'OK' + tty_normal
    tty_error     = tty_red + tty_bold + 'ERROR' + tty_normal
else:
    tty_black     = ''
    tty_red       = ''
    tty_green     = ''
    tty_yellow    = ''
    tty_blue      = ''
    tty_magenta   = ''
    tty_cyan      = ''
    tty_white     = ''
    tty_bgred     = ''
    tty_bggreen   = ''
    tty_bgyellow  = ''
    tty_bgblue    = ''
    tty_bgmagenta = ''
    tty_bgcyan    = ''
    tty_bold      = ''
    tty_underline = ''
    tty_normal    = ''
    tty_ok        = 'OK'
    tty_error     = 'ERROR'

def ok():
    sys.stdout.write(tty_ok + "\n")

# Symbols for update
good  = " " + tty_green +  tty_bold + "*" + tty_normal
warn  = " " + tty_bgyellow + tty_black + tty_bold + "!" + tty_normal
error = " " + tty_bgred +  tty_white +   tty_bold + "!" + tty_normal

# Options to set via command line
opt_verbose = False
opt_interactive = False
opt_force = False

g_hooks = None

def show_success(exit_code):
    if exit_code == True or exit_code == 0:
        ok()
    else:
        sys.stdout.write(tty_error + "\n")
    return exit_code

patch_supports_merge = None
def patch_has_merge():
    # check wether our version of patch supports the option '--merge'
    global patch_supports_merge
    if patch_supports_merge == None:
        patch_supports_merge = (0 == os.system("true | PATH=/omd/versions/default/bin:$PATH patch --merge >/dev/null 2>&1"))
        if not patch_supports_merge:
            sys.stdout.write("Your version of patch does not support --merge.\n")
    return patch_supports_merge


def run_dialog(args):
    env = {
        "TERM": getenv("TERM", "linux"),
        "LANG": "de_DE.UTF-8"
    }
    p = Popen(["dialog", "--shadow"] + args, env = env, stderr = PIPE)
    response = p.stderr.read()
    return 0 == os.waitpid(p.pid, 0)[1], response

def dialog_menu(title, text, choices, defvalue, oktext, canceltext):
    args = [ "--ok-label", oktext, "--cancel-label", canceltext ]
    if defvalue != None:
        args += [ "--default-item", defvalue ]
    args += [ "--title", title, "--menu", text, "0", "0", "0" ] # "20", "60", "17" ]
    for text, value in choices:
        args += [ text, value ]
    return run_dialog(args)

def dialog_regex(title, text, regex, value, oktext, canceltext):
    while True:
        args = [ "--ok-label", oktext, "--cancel-label", canceltext,
                 "--title", title, "--inputbox", text, "0", "0", value ]
        change, new_value = run_dialog(args)
        if not change:
            return False, value
        elif not regex.match(new_value):
            dialog_message("Invalid value. Please try again.")
            value = new_value
        else:
            return True, new_value


def dialog_yesno(text, yeslabel = "yes", nolabel = "no"):
    state, response = run_dialog(["--yes-label", yeslabel, "--no-label", nolabel, "--yesno", text, "0", "0"])
    return state

def dialog_message(text, buttonlabel="OK"):
    run_dialog(["--ok-label", buttonlabel, "--msgbox", text, "0", "0"])

def user_confirms(title, message, relpath, yes_choice, yes_text, no_choice, no_text):
    user_path = g_sitedir + "/" + relpath
    options = [ (yes_choice, yes_text),
                (no_choice,  no_text),
                ("shell",    "Open a shell for looking around"),
                ("abort",    "Stop here and abort update!")]
    while True:
        choice = ask_user_choices(title, message, options)
        if choice == "abort":
            bail_out("Update aborted.")
        elif choice == "shell":
	    thedir = "/".join(user_path.split("/")[:-1])
            sys.stdout.write("\n Starting BASH. Type CTRL-D to continue.\n\n")
            os.system("cd '%s' ; bash -i" % thedir)
        else:
            return choice == yes_choice


def wrap_text(text, width):
    def fillup(line, width):
        if len(line) < width:
            line += " " * (width - len(line))
        return line

    def justify(line, width):
        need_spaces = float(width - len(line))
        spaces = float(line.count(' '))
        newline = ""
        x = 0.0
        s = 0.0
        words = line.split()
        newline = words[0]
        for word in words[1:]:
            newline += ' '
            x += 1.0
            if s/x < need_spaces / spaces:
                newline += ' '
                s += 1
            newline += word
        return newline

    wrapped = []
    line = ""
    col = 0
    for word in text.split():
        netto = len(word)
        if line != "" and netto + col + 1 > width:
            wrapped.append(justify(line, width))
            col = 0
            line = ""
        if line != "":
            line += ' '
            col += 1
        line += word
        col += netto
    if line != "":
        wrapped.append(fillup(line, width))

    # remove trailing empty lines
    while wrapped[-1].strip() == "":
        wrapped = wrapped[:-1]
    return wrapped

def getch():
   fd = sys.stdin.fileno()
   old_settings = termios.tcgetattr(fd)
   try:
       tty.setraw(sys.stdin.fileno())
       ch = sys.stdin.read(1)
   finally:
       termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
   if ord(ch) == 3:
        raise KeyboardInterrupt()
   return ch


def ask_user_choices(title, message, choices):
    sys.stdout.write("\n")
    def pl(line):
        sys.stdout.write(" %s %-76s %s\n" % (tty_bgcyan + tty_white, line, tty_normal))
    pl("")
    sys.stdout.write(" %s %-76s %s\n" % (tty_bgcyan + tty_white + tty_bold, title, tty_normal))
    for line in wrap_text(message, 76):
        pl(line)
    pl("")
    chars = []
    empty_line = " %s%-78s%s\n" % (tty_bgblue + tty_white, "", tty_normal)
    sys.stdout.write(empty_line)
    for choice, title in choices:
        sys.stdout.write(" %s %s%s%s%-10s %-65s%s\n" % 
                (tty_bgblue + tty_white, tty_bold, choice[0], 
                 tty_normal + tty_bgblue + tty_white, choice[1:], title, tty_normal))
        for c in choice:
            if c.lower() not in chars:
                chars.append(c)
                break
    sys.stdout.write(empty_line)

    choicetxt = (tty_bold + tty_magenta + "/").join([(tty_bold + tty_white + char + tty_normal + tty_bgmagenta) for (char, (c,t)) in zip(chars, choices)])
    l = len(choices) * 2 - 1
    sys.stdout.write(" %s %s" % (tty_bgmagenta, choicetxt))
    sys.stdout.write(" ==> %s   %s" % (tty_bgred, tty_bgmagenta))
    sys.stdout.write(" " * (69 - l))
    sys.stdout.write("\b" * (71 - l))
    sys.stdout.write(tty_normal)
    while True:
        a = getch()
        for char, (choice, title) in zip(chars, choices):
            if a == char:
                sys.stdout.write(tty_bold + tty_bgred + tty_white + a + tty_normal + "\n\n")
                return choice

def bail_out(message):
    sys.exit(message)

def omd_root():
    return "/omd/versions/" + OMD_VERSION

# Read distro- and version specific values
def read_info():
    global g_info
    g_info = {}
    info_dir = omd_root() + "/share/omd"
    for f in os.listdir(info_dir):
        if f.endswith(".info"):
            for line in file(info_dir + "/" + f):
                var, value = line.split('=')
                value = value.strip()
                if var.endswith("+"):
                    var = var[:-1] # remove +
                    g_info[var.strip()] += " " + value
                else:
                    g_info[var.strip()] = value

def read_skel_permissions():
    global g_skel_permissions
    g_skel_permissions = load_skel_permissions(OMD_VERSION)
    if not g_skel_permissions:
        bail_out("%s is missing or currupted." % file_path)

def load_skel_permissions(version):
    perms = {}
    file_path = "/omd/versions/%s/share/omd/skel.permissions" % version
    try:
        for line in file(file_path):
            line = line.strip()
            if line == "" or line[0] == "#":
                continue
            path, perm = line.split()
            mode = int(perm, 8)
            perms[path] = mode
        return perms
    except:
        return None

def get_skel_permissions(version, perms, relpath):
    try:
        return perms[relpath]
    except:
        return get_file_permissions("/omd/versions/%s/skel/%s" % (version, relpath))

def get_file_permissions(path):
    try:
        return os.stat(path).st_mode & 07777
    except:
        return 0

def get_file_owner(path):
    try:
        return pwd.getpwuid(os.stat(path).st_uid)[0]
    except:
        return None

def site_name():
        return pwd.getpwuid(os.getuid()).pw_name

def site_dir(sitename):
    return "/omd/sites/" + sitename

def tmp_dir(sitename):
    return "/omd/sites/%s/tmp" % sitename

# The version of a site is solely determined by the
# link ~SITE/version
def site_version(sitename):
    version_link = site_dir(sitename) + "/version"
    try:
        version = os.readlink(version_link).split("/")[-1]
        return version
    except:
        return None

def create_version_symlink(sitename, version):
    linkname = site_dir(sitename) + "/version"
    if os.path.exists(linkname):
        os.remove(linkname)
    os.symlink("../../versions/%s" % OMD_VERSION, linkname)


def site_exists(sitename):
    return os.path.exists(site_dir(sitename))

def all_sites():
    l = [ s for s in os.listdir("/omd/sites") if os.path.isdir(os.path.join("/omd/sites/", s)) ]
    l.sort()
    return l

# Check if site is completely stopped
def site_is_stopped(sitename):
    return check_status(sitename, False) == 1

def site_is_running(sitename):
    return check_status(sitename, False) == 0

def groupdel(groupname):
    os.system("groupdel " + groupname)

def groupadd(groupname, gid = None):
    cmd = "groupadd "
    if gid != None:
        cmd += "-g %d " % int(gid)
    cmd += groupname

    if 0 != os.system(cmd):
        bail_out("Cannot create group for site user.")

def useradd(sitename, uid = None, gid = None):
    # Create user for running site 'name'
    groupadd(sitename, gid)
    useradd_options = g_info["USERADD_OPTIONS"]
    if uid != None:
        useradd_options += " -u %d" % int(uid)
    if 0 != os.system("useradd %s -d '%s' -c 'OMD site %s' -g %s -G omd %s -s /bin/bash" % \
                      (useradd_options, site_dir(sitename), sitename, sitename, sitename)):
        groupdel(sitename)
        bail_out("Error creating site user.")

    # Add Apache to new group. It needs to be able to write in to the
    # command pipe and possible other stuff
    add_user_to_group(g_info["APACHE_USER"], sitename)

def add_user_to_group(user, group):
    cmd = g_info["ADD_USER_TO_GROUP"] % {"user": user, "group" : group}
    return os.system(cmd + " >/dev/null") == 0

def userdel(name):
    os.system("userdel -r " + name + " 2>/dev/null")
    # On some OSes (e.g. debian) the group is automatically removed if
    # it bears the same name as the user. So first check for the group.
    if group_exists(name):
        groupdel(name)

def user_exists(name):
    try:
        pwd.getpwnam(name)
        return True
    except:
        return False

def group_exists(name):
    try:
        grp.getgrnam(name)
        return True
    except:
        return False

def group_id(name):
    try:
        g = grp.getgrnam(name)
        return g.gr_gid
    except:
        return None

def user_logged_in(name):
    # Check, if processes of named user are existing
    return os.system("ps --no-headers --user '%s' >/dev/null 2>&1" % name) == 0

def switch_to_site_user():
    p = pwd.getpwnam(g_sitename)
    uid = p.pw_uid
    gid = p.pw_gid
    os.chdir(p.pw_dir)
    os.setgid(gid)
    os.setgroups([group_id('omd')])
    os.setuid(uid)

def switch_temp_to_user(user):
    p = pwd.getpwnam(user)
    uid = p.pw_uid
    gid = p.pw_gid
    os.chdir(p.pw_dir)
    os.setegid(gid)
    os.seteuid(uid)

def switch_back_to_root():
    os.setgid(0)
    os.setuid(0)


# Starts a subprocess to execute a python function as other user
# without switching the user for the whole main process
#
# Would need:
# try:
#    from multiprocessing import Process
# except:
#     # The package is named processing in debian
#     from processing import Process
#
# Has been removed since multiprocessing is not available on
# e.g. CentOS. Too modern stuff...
def execute_as_user(function, arguments):
    def run():
        switch_to_site_user()
        function(*arguments)
    p = Process(target=run)
    p.start()
    p.join(20)

# No using os.putenv, os.getenv os.unsetenv directly because
# they seem not to work correctly in debian 503.
#
# Unsetting all vars with os.unsetenv and after that using os.getenv to read
# some vars did not bring the expected result that the environment was empty.
# The vars were still set.
#
# Same for os.putenv. Executing os.getenv right after os.putenv did not bring
# the expected result.
#
# Directly modifying os.environ seems to work.
def putenv(key, value):
    os.environ[key] = value

def getenv(key, default = None):
    if not key in os.environ:
        return default
    return os.environ[key]

def clear_environment():
    # first remove *all* current environment variables
    keep = [ "TERM" ]
    for key in os.environ.keys():
        if key not in keep:
            del os.environ[key]

def set_environment():
    putenv("OMD_SITE", g_sitename)
    putenv("OMD_ROOT", g_sitedir)
    putenv("PATH", "%s/local/bin:%s/bin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin" %
                                                                  (g_sitedir, g_sitedir))
    putenv("USER", g_sitename)

    putenv("LD_LIBRARY_PATH", "%s/local/lib:%s/lib" % (g_sitedir, g_sitedir))
    putenv("HOME", g_sitedir)
    putenv("PYTHONPATH", "%s/lib/python:%s/local/lib/python" % (g_sitedir, g_sitedir))

    # allow user to define further environment variable in ~/etc/environment
    envfile = g_sitedir + "/etc/environment"
    if os.path.exists(envfile):
        lineno = 0
        for line in file(envfile):
            lineno += 1
            line = line.strip()
            if line == "" or line[0] == "#":
                continue # allow empty lines and comments
            parts = line.split("=")
            if len(parts) != 2:
                bail_out("%s: syntax error in line %d" % (envfile, lineno))
            varname = parts[0]
            value = parts[1]
            if value.startswith('"'):
                value = value.strip('"')

            # Add the present environment when someone wants to append some
            if value.startswith("$%s:" % varname):
                before = getenv(varname, None)
                if before:
                    value = before + ":" + value.replace("$%s:" % varname, '')

            if value.startswith("'"):
                value = value.strip("'")
            putenv(varname, value)

def hostname():
    try:
        return os.popen("hostname").read().strip()
    except:
        return "localhost"

def tmpfs_mounted(sitename):
    # Problem here: if /omd is a symbolic link somewhere else,
    # then in /proc/mounts the physical path will appear and be
    # different from tmp_path. We just check the suffix therefore.
    path_suffix = "sites/%s/tmp" % sitename
    for line in file("/proc/mounts"):
        device, mp, fstype, options, dump, fsck = line.split()
        if mp.endswith(path_suffix) and fstype == 'tmpfs':
            return True
    return False

def create_tmpfs(sitename):
    if tmpfs_mounted(sitename):
        return
    if os.getuid() == 0:
        switch_to_site_user()

    tmp = tmp_dir(sitename)
    sys.stdout.write("Creating temporary filesystem %s..." % tmp)
    sys.stdout.flush()
    if not os.path.exists(tmp):
        os.mkdir(tmp)
    if 0 != os.system("mount '%s'" % tmp):
        sys.stdout.write(tty_error + "\n")
        return
    create_skeleton_files(sitename, "tmp")
    chown_tree(tmp, sitename)
    ok()

def unmount_tmpfs(sitename):
    if tmpfs_mounted(sitename):
        sys.stdout.write("Unmounting temporary filesystem...")
        for t in range(0, 10):
            if 0 == os.system("umount '%s'" % tmp_dir(sitename)):
                ok()
                return
            sys.stdout.write(".")
            sys.stdout.flush()
            time.sleep(1)
        bail_out(tty_error + ": Cannot unmount tmp filesystem.")

def add_to_fstab(sitename):
    # tmpfs                   /opt/omd/sites/b01/tmp  tmpfs   user,uid=b01,gid=b01 0 0
    mountpoint = tmp_dir(sitename)
    sys.stdout.write("Adding %s to /etc/fstab.\n" % mountpoint)
    file("/etc/fstab", "a+").write("tmpfs  %s tmpfs noauto,user,mode=755,uid=%s,gid=%s 0 0\n" % \
        (mountpoint, sitename, sitename))

def remove_from_fstab(sitename):
    mountpoint = tmp_dir(sitename)
    sys.stdout.write("Removing %s from /etc/fstab..." % mountpoint)
    newtab = file("/etc/fstab.new", "w")
    for line in file("/etc/fstab"):
        if "uid=%s," % sitename in line and mountpoint in line:
            continue
        newtab.write(line)
    os.rename("/etc/fstab.new", "/etc/fstab")
    ok()

def start_site(sitename):
    create_tmpfs(sitename)
    call_init_scripts(sitename, "start")

def create_skeleton_files(sitename, dir):
    read_skel_permissions()
    sitedir = site_dir(sitename)
    replacements = {
        "###SITE###" : sitename,
        "###ROOT###" : sitedir,
    }
    # Hack: exclude tmp if dir is '.'
    exclude_tmp = dir == "."
    skelroot = "/omd/versions/%s/skel" % OMD_VERSION
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk(dir):
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
        for entry in dirnames + filenames:
            if exclude_tmp:
                if dirpath == "." and entry == "tmp":
                    continue
                if dirpath == "tmp" or dirpath.startswith("tmp/"):
                    continue
	    create_skeleton_file(skelroot, sitedir, dirpath + "/" + entry, replacements)

def delete_user_file(user_path):
    if not os.path.islink(user_path) and os.path.isdir(user_path):
        shutil.rmtree(user_path)
    else:
        os.remove(user_path)


def create_skeleton_file(skelbase, userbase, relpath, replacements):
    skel_path = skelbase + "/" + relpath
    user_path = userbase + "/" + relpath

    # Remove old version, if existing (needed during update)
    if os.path.exists(user_path):
        delete_user_file(user_path)

    # Create directories, symlinks and files
    if os.path.islink(skel_path):
        os.symlink(os.readlink(skel_path), user_path)
    elif os.path.isdir(skel_path):
        os.makedirs(user_path)
    else:
        file(user_path, "w").write(replace_tags(file(skel_path).read(), replacements))

    if not os.path.islink(skel_path):
        mode = g_skel_permissions.get(relpath)
        if mode == None:
            if os.path.isdir(skel_path):
                mode = 0755
            else:
                mode = 0644
        os.chmod(user_path, mode)


def create_apache_hook(sitename):
    file("/omd/apache/%s.conf" % sitename, "w").write("Include %s/etc/apache/mode.conf\n" % site_dir(sitename))

def delete_apache_hook(sitename):
    hook_path = "/omd/apache/%s.conf" % sitename
    if not os.path.exists(hook_path):
        return
    try:
        os.remove(hook_path)
    except Exception, e:
        sys.stderr.write("Cannot remove apache hook %s: %s\n" % (hook_path, e))

def reload_apache():
    sys.stdout.write("Reloading Apache...")
    sys.stdout.flush()
    show_success(os.system("%s reload" % g_info["APACHE_CTL"]))

def restart_apache():
    sys.stdout.write("Restarting Apache...")
    sys.stdout.flush()
    show_success(os.system("%s restart >/dev/null" % g_info["APACHE_INIT"]))

def replace_tags(content, replacements):
    for var, value in replacements.items():
        content = content.replace(var, value)
    return content

def stop_if_not_stopped(sitename):
    if not site_is_stopped(sitename):
        stop_site(sitename)

def stop_site(sitename):
    call_init_scripts(sitename, "stop")


# Change site specific information in files originally create from
# skeleton files. Skip files below tmp/
def patch_skeleton_files(old, new):
    skelroot = "/omd/versions/%s/skel" % OMD_VERSION
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk("."):
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
        targetdir = site_dir(new) + "/" + dirpath
        if targetdir.startswith(tmp_dir(new)):
            continue # Skip files below tmp
        for fn in filenames:
            src = dirpath + "/" + fn
            dst = targetdir + "/" + fn
            if os.path.isfile(src) and not os.path.islink(src) \
                and os.path.exists(dst): # not deleted by user
                try:
                    patch_template_file(src, dst, old, new)
                except Exception, e:
                    sys.stderr.write("Error patching template file '%s': %s\n" %
                            (dst, e))


def chown_tree(dir, user):
    uid = pwd.getpwnam(user).pw_uid
    gid = pwd.getpwnam(user).pw_gid
    os.chown(dir, uid, gid)
    for dirpath, dirnames, filenames in os.walk(dir):
        for entry in dirnames + filenames:
            os.lchown(dirpath + "/" + entry, uid, gid)


def try_chown(filename, user):
    if os.path.exists(filename):
        try:
            uid = pwd.getpwnam(user).pw_uid
            gid = pwd.getpwnam(user).pw_gid
            os.chown(filename, uid, gid)
        except Exception, e:
            sys.stderr.write("Cannot chown %s to %s: %s\n" % (filename, user, e))
            pass


def instantiate_skel(path):
    try:
        t = file(path).read()
        replacements = {
            "###SITE###" : g_sitename,
            "###ROOT###" : g_sitedir,
        }
        return replace_tags(t, replacements)
    except:
        return "" # e.g. due to permission error


def patch_template_file(src, dst, old, new):
    # Create patch from old instantiated skeleton file to new one
    content = file(src).read()
    for site in [ old, new ]:
        replacements = {
            "###SITE###" : site,
            "###ROOT###" : site_dir(site),
        }
        filename = "%s.skel.%s" % (dst, site)
        file(filename, "w").write(replace_tags(content, replacements))
        try_chown(filename, new)

    # If old and new skeleton file are identical, then do nothing
    old_orig_path = "%s.skel.%s" % (dst, old) 
    new_orig_path = "%s.skel.%s" % (dst, new) 
    if file(old_orig_path).read() == file(new_orig_path).read():
        os.remove(old_orig_path)
        os.remove(new_orig_path)
        return

    # Now create a patch from old to new and immediately apply on
    # existing - possibly user modified - file.
    
    result = os.system("diff -u %s %s | %s/bin/patch --force --backup --forward --silent %s" %
            (old_orig_path, new_orig_path, site_dir(new), dst))
    try_chown(dst, new)
    try_chown(dst + ".rej", new) 
    try_chown(dst + ".orig", new)
    if result == 0:
        sys.stdout.write(good + " Converted      %s\n" % src)
    else:
        # Make conflict resolution interactive - similar to omd update
        options = [
            ( "diff",      "Show conversion patch, that I've tried to apply" ),
            ( "you",       "Show your changes compared with the original default version" ),
            ( "edit",      "Edit half-converted file (watch out for >>>> and <<<<)" ),
            ( "try again", "Edit your original file and try again"),
            ( "keep",      "Keep half-converted version of the file" ),
            ( "restore",   "Restore your original version of the file" ),
            ( "install",   "Install the default version of the file" ),
            ( "brute",     "Simply replace /%s/ with /%s/ in that file" % (old, new)),
            ( "shell",     "Open a shell for looking around" ),
            ( "abort",     "Stop here and abort!" ),
        ]

        while True:
            choice = ask_user_choices("Conflicts in " + src + "!", "I've tried to merge your changes with the renaming of %s into %s.\n"
               "Unfortunately there are conflicts with your changes. \n"
               "You have the following options: " %
                    ( old, new ), options)
            if choice == "abort":
                bail_out("Renaming aborted.")
            elif choice == "keep":
                break
            elif choice == "edit":
                os.system("%s '%s'" % (get_editor(), dst))
            elif choice == "diff":
                os.system("diff -u %s %s%s" % (old_orig_path, new_orig_path, pipe_pager()))
            elif choice == "brute":
                os.system("sed 's@/%s/@/%s/@g' %s.orig > %s" % (old, new, dst, dst))
                changed = len([ l for l in os.popen("diff %s.orig %s" % (dst, dst)).readlines()
                  if l.startswith(">") ])
                if changed == 0:
                    sys.stdout.write("Found no matching line.\n")
                else:
                    sys.stdout.write("Did brute-force replace, changed %s%d%s lines:\n" % 
                      (tty_bold, changed, tty_normal))
                    os.system("diff -u %s.orig %s" % (dst, dst))
                    break
            elif choice == "you":
                os.system("pwd ; diff -u %s %s.orig%s" % (old_orig_path, dst, pipe_pager()))
            elif choice == "restore":
                os.rename(dst + ".orig", dst)
                sys.stdout.write("Restored your version.\n")
                break
            elif choice == "install":
                os.rename(new_orig_path, dst)
                sys.stdout.write("Installed default file (with site name %s).\n" % new)
                break
            elif choice == "shell":
                relname = src.split("/")[-1]
                sys.stdout.write(" %-35s the half-converted file\n" % (relname,))
                sys.stdout.write(" %-35s your original version\n" % (relname + ".orig"))
                sys.stdout.write(" %-35s the failed parts of the patch\n" % (relname + ".rej"))
                sys.stdout.write(" %-35s default version with the old site name\n" % (relname + ".skel.%s" % old))
                sys.stdout.write(" %-35s default version with the new site name\n" % (relname + ".skel.%s" % new))

                sys.stdout.write("\n Starting BASH. Type CTRL-D to continue.\n\n")
                thedir = "/".join(dst.split("/")[:-1])
                os.system("su - %s -c 'cd %s ; bash -i'" % (new, thedir))

    # remove unnecessary files
    try:
        os.remove(dst + ".skel." + old)
        os.remove(dst + ".skel." + new)
        os.remove(dst + ".orig")
        os.remove(dst + ".rej")
    except:
        pass

def get_editor():
    editor = getenv("VISUAL", getenv("EDITOR", "/usr/bin/vi"))
    if not os.path.exists(editor):
        editor = 'vi'
    return editor

# return "| $PAGER", if a pager is available
def pipe_pager():
    pager = getenv("PAGER")
    if not pager and os.path.exists("/usr/bin/less"):
        pager = "less -F"
    if pager:
        return "| %s" % pager
    else:
        return ""

# Try to merge changes from old->new version and
# old->user version
def merge_update_file(relpath, old_version, new_version):
    fn = tty_bold + relpath + tty_normal

    replacements = {
        "###SITE###" : g_sitename,
        "###ROOT###" : g_sitedir,
    }
    user_path = g_sitedir + "/" + relpath
    content = file(user_path).read()
    permissions = os.stat(user_path).st_mode

    def try_merge():
        for version in [ old_version, new_version ]:
            p = "/omd/versions/%s/skel/%s" % (version, relpath)
            while True:
                try:
                    skel_content = file(p).read()
                    break
                except:
                    if not user_confirms("Skeleton file of version %s not readable" % version,
                        "The file '%s' is not readable for the site user. "
                        "This is most probably due a bug in release 0.42. "
                        "You can either fix that problem by making the file "
                        "readable with doing as root: chmod +r '%s' "
                        "or assume the file as empty. In that case you might "
                        "damage your configuration file "
                        "in case you have made changes to it in your site. What shall we do?" %
                        (p, p),
                        relpath,
                        "retry", "Retry reading the file (after you've fixed it)",
                        "ignore", "Assume the file to be empty"):
                        skel_content = ""
                        break
            file("%s-%s" % (user_path, version), "w").write(replace_tags(skel_content, replacements))
        version_patch = os.popen("diff -u %s-%s %s-%s" % (user_path, old_version, user_path, new_version)).read()

        # First try to merge the changes in the version into the users' file
        merge = patch_has_merge() and "--merge" or ""
        f = os.popen("PATH=/omd/versions/default/bin:$PATH patch --force --backup --forward --silent %s %s >/dev/null" % (merge, user_path), "w")
        f.write(version_patch)
        status = f.close()
        if status:
            return status / 256
        else:
            return 0

    if try_merge() == 0:
        # ACHTUNG: Hier müssen die Dateien $DATEI-alt, $DATEI-neu und $DATEI.orig
        # gelöscht werden
        sys.stdout.write(good + " Merged         %s\n" % fn)
        return

    # No success. Should we try merging the users' changes onto the new file?
    # user_patch = os.popen(
    merge_message = patch_has_merge() and ' (watch out for >>>>> and <<<<<)' or ''
    editor = get_editor()
    reject_file = user_path + ".rej"

    options = [
        ( "diff",      "Show differences between the new default and your version" ),
        ( "you",       "Show your changes compared with the old default version" ),
        ( "new",       "Show what has changed from %s to %s" % (old_version, new_version) ) ]
    if os.path.exists(reject_file): # missing if patch has --merge
        options.append( ( "missing",   "Show which changes from the update have not been merged" ))
    options += [
        ( "edit",      "Edit half-merged file%s" % merge_message ),
        ( "try again", "Edit your original file and try again"),
        ( "keep",      "Keep half-merged version of the file" ),
        ( "restore",   "Restore your original version of the file" ),
        ( "install",   "Install the new default version" ),
        ( "shell",     "Open a shell for looking around" ),
        ( "abort",     "Stop here and abort update!" ),
    ]

    while True:
        choice = ask_user_choices("Conflicts in " + relpath + "!", "I've tried to merge the changes from version %s to %s into %s.\n"
           "Unfortunately there are conflicts with your changes. \n"
           "You have the following options: " %
                ( old_version, new_version, relpath ), options)
        if choice == "abort":
            bail_out("Update aborted.")
        elif choice == "keep":
            break
        elif choice == "edit":
            os.system("%s '%s'" % (editor, user_path))
        elif choice == "diff":
            os.system("diff -u %s.orig %s-%s%s" % (user_path, user_path, new_version, pipe_pager()))
        elif choice == "you":
            os.system("diff -u %s-%s %s.orig%s" % (user_path, old_version, user_path, pipe_pager()))
        elif choice == "new":
            os.system("diff -u %s-%s %s-%s%s" % (user_path, old_version, user_path, new_version, pipe_pager()))
        elif choice == "missing":
            if os.path.exists(reject_file):
                sys.stdout.write(tty_bgblue + tty_white + file(reject_file).read() + tty_normal)
            else:
                sys.stdout.write("File %s not found.\n" % reject_file)

        elif choice == "shell":
            relname = relpath.split("/")[-1]
            sys.stdout.write(" %-25s: the current half-merged file\n" % relname)
            sys.stdout.write(" %-25s: the default version of %s\n" % (relname + "." + old_version, old_version))
            sys.stdout.write(" %-25s: the default version of %s\n" % (relname + "." + new_version, new_version))
            sys.stdout.write(" %-25s: your original version\n" % (relname + ".orig"))
            if os.path.exists(reject_file):
                sys.stdout.write(" %-25s: changes that haven't been merged\n" % relname + ".rej")

            sys.stdout.write("\n Starting BASH. Type CTRL-D to continue.\n\n")
            thedir = "/".join(user_path.split("/")[:-1])
            os.system("cd '%s' ; bash -i" % thedir)
        elif choice == "restore":
            os.rename(user_path + ".orig", user_path)
            os.chmod(user_path, permissions)
            sys.stdout.write("Restored your version.\n")
            break
        elif choice == "try again":
            os.rename(user_path + ".orig", user_path)
            os.system("%s '%s'" % (editor, user_path))
            if 0 == try_merge():
                sys.stdout.write("Successfully merged changes from %s -> %s into %s\n" %
                        (old_version, new_version, fn))
                return
            else:
                sys.stdout.write(" Merge failed again.\n")

        else: # install
            os.rename("%s-%s" % (user_path, new_version), user_path)
            os.chmod(user_path, permissions)
            sys.stdout.write("Installed default file of version %s.\n" % new_version)
            break

    # Clean up temporary files
    for p in [ "%s-%s" % (user_path, old_version),
               "%s-%s" % (user_path, new_version),
               "%s.orig" % user_path,
               "%s.rej" % user_path]:
        try:
            os.remove(p)
        except:
            pass


def filetype(p):
    # check for symlinks first. Might be dangling. In that
    # case os.path.exists checks the links target for existance
    # and reports it is non-existing.
    if os.path.islink(p):
        tp = "link"
    elif not os.path.exists(p):
        tp = None
    elif os.path.isdir(p):
        tp = "dir"
    else:
        tp = "file"

    return tp


def file_contents(path):
    """ Returns the file contents of a site file or a skel file """
    if '/skel/' in path:
        return instantiate_skel(path)
    else:
        return file(path).read()


def file_status(source_path, target_path):
    """ Compares two files and returns infos wether the file type or contants have changed """
    source_type  = filetype(source_path)
    target_type  = filetype(target_path)

    if source_type == "file":
        source_content = file_contents(source_path)

    if target_type == "file":
        target_content = file_contents(target_path)

    changed_type = source_type != target_type
    # FIXME: Was ist, wenn aus einer Datei ein Link gemacht wurde? Oder umgekehrt?
    changed_content = (source_type == "file" \
                       and target_type == "file" \
                       and source_content != target_content) or \
                      (source_type == "link" \
                       and target_type == "link" \
                       and os.readlink(source_path) != os.readlink(target_path))
    changed = changed_type or changed_content

    return (changed_type, changed_content, changed)


def update_file(relpath, old_version, new_version, userdir, old_perms):
    old_skel = "/omd/versions/%s/skel" % old_version
    new_skel = "/omd/versions/%s/skel" % new_version

    replacements = {
        "###SITE###" : g_sitename,
        "###ROOT###" : g_sitedir,
    }

    old_path = old_skel + "/" + relpath
    new_path = new_skel + "/" + relpath
    user_path = userdir + "/" + relpath

    old_type  = filetype(old_path)
    new_type  = filetype(new_path)
    user_type = filetype(user_path)

    # compare our new version with the user's version
    type_differs, content_differs, differs = file_status(user_path, new_path)

    # compare our old version with the user's version
    user_changed_type, user_changed_content, user_changed = file_status(old_path, user_path)

    # compare our old with our new version
    we_changed_type, we_changed_content, we_changed = file_status(old_path, new_path)

#     if opt_verbose:
#         sys.stdout.write("%s%s%s:\n" % (tty_bold, relpath, tty_normal))
#         sys.stdout.write("  you       : %s\n" % user_type)
#         sys.stdout.write("  %-10s: %s\n" % (old_version, old_type))
#         sys.stdout.write("  %-10s: %s\n" % (new_version, new_type))

    # A --> MISSING FILES

    # Handle cases with missing files first. At least old or new are present,
    # or this function would never have been invoked.
    fn = tty_bold + tty_bgblue + tty_white + relpath + tty_normal
    fn = tty_bold + relpath + tty_normal

    # 1) New version ships new skeleton file -> simply install
    if not old_type and not user_type:
        create_skeleton_file(new_skel, userdir, relpath, replacements)
        sys.stdout.write(good + " Installed %-4s %s\n" % (new_type, fn))

    # 2) new version ships new skeleton file, but user's own file/dir/link
    #    is in the way.
    # 2a) the users file is identical with our new version
    elif not old_type and not differs:
            sys.stdout.write(good + " Identical new  %s\n" % fn)

    # 2b) user's file has a different content or type
    elif not old_type:
        if user_confirms("Conflict at " + relpath,
                    "The new version ships the %s %s, "
                    "but you have created a %s in that place "
                    "yourself. Shall we keep your %s or replace "
                    "is with my %s?" % (new_type, relpath, user_type, user_type, new_type),
                    relpath,
                    "keep", "Keep your %s" % user_type,
                    "replace", "Replace your %s with the new default %s" % (user_type, new_type)):
            sys.stdout.write(warn + " Keeping your   %s\n" % fn)
        else:
            create_skeleton_file(new_skel, userdir, relpath, replacements)
            sys.stdout.write(good + " Installed %-4s %s\n" % (new_type, fn))

    # 3) old version had a file which has vanished in new (got obsolete). If the user
    #    has deleted it himself, we are just happy
    elif not new_type and not user_type:
        sys.stdout.write(good + " Obsolete       %s\n" % fn)

    # 3b) same, but user has not deleted and changed type
    elif not new_type and user_changed_type:
        if user_confirms("Obsolete file " + relpath,
                    "The %s %s has become obsolete in "
                    "this version, but you have changed it into a "
                    "%s. Do you want to keep your %s or "
                    "may I delete it for you, please?" % (old_type, relpath, user_type, user_type),
                    relpath,
                    "keep", "Keep your %s" % user_type,
                    "delete", "Delete it"):
            sys.stdout.write(warn + " Keeping your   %s\n" % fn)
        else:
            delete_user_file(user_path)
            sys.stdout.write(warn + " Deleted        %s\n" % fn)

    # 3c) same, but user has changed it contents
    elif not new_type and user_changed_content:
        if user_confirms("Changes in obsolete %s %s" % (old_type, relpath),
                "The %s %s has become obsolete in "
                "the new version, but you have changed its contents. "
                "Do you want to keep your %s or "
                "may I delete it for you, please?" % (old_type, relpath, user_type),
                relpath,
                "keep", "keep your %s, though it is obsolete" % user_type,
                "delete", "delete your %s" % user_type):
            sys.stdout.write(warn + " Keeping your   %s\n" % fn)
        else:
            delete_user_file(user_path)
            sys.stdout.write(warn + " Deleted        %s\n" % fn)

    # 3d) same, but user hasn't changed anything -> silently delete
    elif not new_type:
        delete_user_file(user_path)
        sys.stdout.write(good + " Vanished       %s\n" % fn)

    # 4) old and new exist, but user file not. User has deleted that
    #    file. We simply do nothing in that case. The user surely has
    #    a good reason why he deleted the file.
    elif not user_type and not we_changed:
        sys.stdout.write(good + " Unwanted       %s (unchanged, deleted by you)\n" % fn)

    # 4b) File changed in new version. Simply warn if user has deleted it.
    elif not user_type:
        sys.stdout.write(warn + " Missing        %s\n" % fn)

    # B ---> UNCHANGED, EASY CASES

    # 5) New version didn't change anything -> no need to update
    elif not we_changed:
        pass

    # 6) User didn't change anything -> take over new version
    elif not user_changed:
        create_skeleton_file(new_skel, userdir, relpath, replacements)
        sys.stdout.write(good + " Updated        %s\n" % fn)

    # 7) User changed, but accidentally exactly as we did -> no action neccessary
    elif not differs:
        sys.stdout.write(good + " Identical      %s\n" % fn)

    # TEST UNTIL HERE

    # C ---> PATCH DAY, HANDLE FILES
    # 7) old, new and user are files. And all are different
    elif old_type == "file" and new_type == "file" and user_type == "file":
        try:
            merge_update_file(relpath, old_version, new_version)
        except KeyboardInterrupt:
            raise
        except Exception, e:
            sys.stdout.write(error + " Cannot merge: %s\n" % e)

    # D ---> SYMLINKS
    # 8) all are symlinks, all changed
    elif old_type == "link" and new_type == "link" and user_type == "link":
        if user_confirms("Symbolic link conflict at " + relpath,
                "'%s' is a symlink that pointed to "
                "%s in the old version and to "
                "%s in the new version. But meanwhile you "
                "changed to link target to %s. "
                "Shall I keep your link or replace it with "
                "the new default target?" %
                (relpath, os.readlink(old_path), os.readlink(new_path), os.readlink(user_path)),
                relpath,
                "keep", "Keep your symbolic link pointing to %s" % os.readlink(user_path),
                "replace", "Change link target to %s" % os.readlink(new_path)):
            sys.stdout.write(warn + " Keeping your   %s\n" % fn)
        else:
            os.remove(user_path)
            os.symlink(os.readlink(new_path), user_path)
            sys.stdout.write(warn + " Set link       %s to new target %s\n" % (fn, os.readlink(new_path)))

    # E ---> FILE TYPE HAS CHANGED (NASTY)

    # Now we have to handle cases, where the file types of the three
    # versions are not identical and at the same type the user or
    # have changed the third file to. We cannot merge here, the user
    # has to decide wether to keep his version of use ours.

    # 9) We have changed the file type
    elif old_type != new_type:
        if user_confirms("File type change at " + relpath,
                "The %s %s has been changed into a %s in "
                "the new version. Meanwhile you have changed "
                "the %s of your copy of that %s. "
                "Do you want to keep your version or replace "
                "it with the new default? " %
                (old_type, relpath, new_type, user_changed_type and "type" or "content",
                 old_type),
                relpath,
                "keep", "Keep your %s" % user_type,
                "replace", "Replace it with the new %s" % new_type):
            sys.stdout.write(warn + " Keeping your version of %s\n" % fn)
        else:
            create_skeleton_file(new_skel, userdir, relpath, replacements)
            sys.stdout.write(warn + " Replaced your %s %s by new default %s.\n" % (user_type, relpath, new_type))

    # 10) The user has changed the file type, we just the content
    elif old_type != user_type:
        if user_confirms("Type change conflicts with content change at " + relpath,
                "Usually %s is a %s in both the "
                "old and new version. But you have changed it "
                "into a %s. Do you want to keep that or may "
                "I replace your %s with the new default "
                "%s, please?" %
                (relpath, old_type, user_type, user_type, new_type),
                relpath,
                "keep", "Keep your %s" % user_type,
                "replace", "Replace it with the new %s" % new_type):
            sys.stdout.write(warn + " Keeping your %s %s.\n" % (user_type, fn))
        else:
            create_skeleton_file(new_skel, userdir, relpath, replacements)
            sys.stdout.write(warn + " Delete your %s and created new default %s %s.\n" %
                    (user_type, new_type, fn))

    # 11) This case should never happen, if I've not lost something
    else:
        if user_confirms("Something nasty happened at " + relpath,
               "You somehow fiddled along with "
               "%s, and I do not have the "
               "slightest idea what's going on here. May "
               "I please install the new default %s "
               "here, or do you want to keep your %s?" %
               (relpath, new_type, user_type),
               relpath,
               "keep", "Keep your %s" % user_type,
               "replace", "Replace it with the new %s" % new_type):
            sys.stdout.write(warn + " Keeping your %s %s.\n" % (user_type, fn))
        else:
            create_skeleton_file(new_skel, userdir, relpath, replacements)
            sys.stdout.write(warn + " Delete your %s and created new default %s %s.\n" % (user_type, new_type, fn))


    # Now the new file/link/dir is in place, deleted or whatever. The
    # user might have interferred and changed things. We need to make sure
    # that file permissions are also updated. But the user might have changed
    # something himself.

    user_type = filetype(user_path)
    old_perm     = get_skel_permissions(old_version, old_perms, relpath)
    new_perm     = get_skel_permissions(new_version, g_skel_permissions, relpath)
    user_perm    = get_file_permissions(user_path)

    # Fix permissions not for links and only if the new type is as expected
    # and the current permissions are not as the should be
    what = None
    if new_type != "link" \
        and user_type == new_type \
        and user_perm != new_perm:

        # Permissions have changed, but file type not
        if old_type == new_type \
            and user_perm != old_perm \
            and old_perm != new_perm:
            if user_confirms("Permission conflict at " + relpath,
                    "The proposed permissions of %s have changed from %04o "
                    "to %04o in the new version, but you have set %04o. "
                    "May I use the new default permissions or do "
                    "you want to keep yours?" %
                    (relpath, old_perm, new_perm, user_perm),
                    relpath,
                    "keep", "Keep permissions at %04o" % user_perm,
                    "default", "Set permission to %04o" % new_perm):
                what = "keep"
            else:
                what = "default"


        # Permissions have changed, no conflict with user
        elif old_type == new_type \
            and user_perm == old_perm:
                what = "default"

        # Permissions are not correct: all other cases (where type is as expected)
        elif old_perm != new_perm:
            if user_confirms("Wrong permission of " + relpath,
                    "The proposed permissions of %s are %04o, but currently are "
                    "%04o. May I use the new default "
                    "permissions or keep yours?" % (relpath, new_perm, user_perm),
                    relpath,
                    "keep", "Keep permissions at %04o" % user_perm,
                    "default", "Set permission to %04o" % new_perm):
                what = "keep"
            else:
                what = "default"

        if what == "keep":
            sys.stdout.write(warn + " Permissions    %04o %s (unchanged)\n" % (user_perm, fn))
        elif what == "default":
            try:
                os.chmod(user_path, new_perm)
                sys.stdout.write(good + " Permissions    %04o -> %04o %s\n" % (user_perm, new_perm, fn))
            except Exception, e:
                sys.stdout.write(error + " Permission:    cannot change %04o -> %04o %s: %s\n" % (user_perm, new_perm, fn, e))


def init_scripts(sitename):
    rc_dir = "/omd/sites/%s/etc/rc.d" % sitename
    try:
        scripts = os.listdir(rc_dir)
        scripts.sort()
        return rc_dir, scripts
    except:
        return rc_dir, []

def call_init_scripts(sitename, command, daemon = None):
    # Restart: Do not restart each service after another,
    # but first do stop all, then start all again! This
    # preserves the order.
    if command == "restart":
        call_init_scripts(sitename, "stop", daemon)
        call_init_scripts(sitename, "start", daemon)
        return

    # OMD guarantees OMD_ROOT to be the current directory
    os.chdir(site_dir(sitename))

    # Call stop scripts in reverse order. If daemon is set,
    # then only that start script will be affected
    rc_dir, scripts = init_scripts(sitename)
    if command == "stop":
        scripts.reverse()
    ok = True
    for script in scripts:
        if daemon and script.split("-", 1)[-1] != daemon:
            continue
        if not os.system("%s/%s %s" % (rc_dir, script, command)) >> 8 in [ 0, 5 ]:
            ok = False
    if ok:
         return 0
    else:
         return 2

def check_status(sitename, display=True, daemon=None, bare=False):
    num_running = 0
    num_unused = 0
    num_stopped = 0
    rc_dir, scripts = init_scripts(sitename)
    for script in scripts:
        komponent = script.split("/")[-1].split('-', 1)[-1]
        if daemon and komponent != daemon:
            continue

        state = os.system("%s/%s status >/dev/null 2>&1" % (rc_dir, script)) >> 8

        if display and (state != 5 or opt_verbose):
	    if bare:
		sys.stdout.write(komponent + " ")
	    else:
		sys.stdout.write("%-16s" % (komponent + ":"))
		sys.stdout.write(tty_bold)

	if bare:
	    if state != 5 or opt_verbose:
		sys.stdout.write("%d\n" % state)

        if state == 0:
            if display and not bare:
                sys.stdout.write(tty_green + "running\n")
            num_running += 1
        elif state == 5:
            if display and opt_verbose and not bare:
                sys.stdout.write(tty_blue + "unused\n")
            num_unused += 1
        else:
            if display and not bare:
                sys.stdout.write(tty_red + "stopped\n")
            num_stopped += 1
        if display and not bare:
            sys.stdout.write(tty_normal)

    if num_stopped > 0 and num_running == 0:
        exit_code = 1
        ovstate = tty_red + "stopped"
    elif num_running > 0 and num_stopped == 0:
        exit_code = 0
        ovstate = tty_green + "running"
    elif num_running == 0 and num_stopped == 0:
        exit_code = 0
        ovstate = tty_blue + "unused"
    else:
        exit_code = 2
        ovstate = tty_yellow + "partially running"
    if display:
	if bare:
	    sys.stdout.write("OVERALL %d\n" % exit_code)
	else:
	    sys.stdout.write("-----------------------\n")
            sys.stdout.write("Overall state:  %s\n" %
                (tty_bold + ovstate + tty_normal))
    return exit_code


def config_load():
    confpath = g_sitedir + "/etc/omd/site.conf"
    if not os.path.exists(confpath):
        return

    for line in file(confpath):
        line = line.strip()
        if line == "" or line[0] == "#":
            continue
        var, value = line.split("=", 1)
        value = value.strip('"').strip("'")
        var = var.strip()
        if not var.startswith("CONFIG_"):
            sys.stderr.write("Ignoring invalid variable %s.\n" % var)
        else:
            os.putenv(var, value)
            var = var[7:]
            if var in g_hooks:
                g_hooks[var]["value"] = value

def config_save():
    confdir = g_sitedir + "/etc/omd"
    if not os.path.exists(confdir):
        os.mkdir(confdir)
    f = file(g_sitedir + "/etc/omd/site.conf", "w")
    hooknames = g_hooks.keys()
    hooknames.sort()
    for hookname in hooknames:
        hook = g_hooks[hookname]
        f.write("CONFIG_%s='%s'\n" % (hookname, hook["value"]))


# Get information about all hooks
def config_load_hooks(force_reload = False):
    global g_hooks
    if not force_reload and g_hooks != None:
        return # already loaded

    g_hooks = {}
    hook_dir = g_sitedir + "/lib/omd/hooks"
    for hookname in os.listdir(hook_dir):
        try:
            if hookname[0] != '.':
                hook = config_load_hook(hookname)
                # only load configuration hooks
                if hook.get("choices", None) != None:
                    g_hooks[hookname] = hook
        except:
            pass
    # now load actual values from site.conf, if available
    config_load()
    load_hook_dependencies()

def config_reload_hooks():
    config_load_hooks(True)

def load_hook_dependencies():
    for hookname, hook in g_hooks.items():
        exitcode, content = call_hook(hookname, ["depends"])
        if exitcode:
            hook["active"] = False
        else:
            hook["active"] = True
        

def refresh_hooks():
    config_load_hooks()
    config_set_all() # execute 'set' functions with current values
    call_all_hooks("refresh")
    config_save()
    config_reload_hooks()

def call_hook(hookname, args):
    hook_file = g_sitedir + "/lib/omd/hooks/" + hookname
    argsstring = " ".join([ "'%s'" % arg for arg in args ])
    putenv("OMD_ROOT", g_sitedir)
    putenv("OMD_SITE", g_sitename)
    pipe = os.popen(hook_file + " " + argsstring)
    content = pipe.read().strip()
    exitcode = pipe.close()
    return exitcode, content

def call_all_hooks(command):
    hook_dir = g_sitedir + "/lib/omd/hooks"
    for hookname in os.listdir(hook_dir):
        commandline = '%s/%s "%s"' % (hook_dir, hookname, command)
        if os.getuid() == 0:
            os.system("su - %s -c '%s'" % (g_sitename, commandline))
        else:
            os.system(commandline)

def config_load_hook(hookname):
    hook = { "name" : hookname }

    description = ""
    description_active = False
    for line in file(g_sitedir + "/lib/omd/hooks/" + hookname):
        if line.startswith("# Alias:"):
            hook["alias"] = line[8:].strip()
        elif line.startswith("# Menu:"):
            hook["menu"] = line[7:].strip()
        elif line.startswith("# Description:"):
            description_active = True
        elif line.startswith("#  ") and description_active:
            description += line[3:].strip() + "\n"
        else:
            description_active = False
    hook["description"] = description

    def get_hook_info(info):
        return call_hook(hookname, [info])[1]

    hook["default"] = get_hook_info("default")
    hook["value"] = hook["default"]
    # The choices can either be a list of possible keys. Then
    # the hook outputs one live for each choice where the key and a
    # description are separated by a colon. Or it outputs one line
    # where that line is an extended regular expression matching the
    # possible values.
    choicestxt = get_hook_info("choices").split("\n")
    if len(choicestxt) == 1:
        regextext = choicestxt[0].strip()
        if regextext != "":
            choices = re.compile(regextext + "$")
        else:
            choices = None
    else:
        choices = []
        try:
            for line in choicestxt:
                val, descr = line.split(":", 1)
                val = val.strip()
                descr = descr.strip()
                choices.append( (val, descr) )
        except:
            bail_out("Invalid output of hook: %s" % choicestxt)

    hook["choices"] = choices
    return hook


def config_set(args):
    if len(args) != 2:
        sys.stderr.write("Please specify variable name and value\n")
        config_usage()
        return

    if not site_is_stopped(g_sitename):
        sys.stderr.write("Cannot change config variables while site is running.\n")
        return

    hookname = args[0]
    value = args[1]
    hook = g_hooks.get(hookname)
    if not hook:
        sys.stderr.write("No such variable '%s'\n" % hookname)
        return

    # Check if value is valid. Choices are either a list of allowed
    # keys or a regular expression
    if type(hook["choices"]) == list:
        choices = [ var for (var, descr) in hook["choices"] ]
        if value not in choices:
            sys.stderr.write("Invalid value for '%s'. Allowed are: %s\n" % \
                    (value, ", ".join(choices)))
            return
    else:
        if not hook["choices"].match(value):
            sys.stderr.write("Invalid value for '%s'. Does not match allowed pattern.\n" % value)
            return

    config_set_value(hookname, value)

def config_set_all():
    for hookname, hook in g_hooks.items():
        config_set_value(hookname, hook["value"])

def config_set_value(hookname, value):
    hook = g_hooks.get(hookname)

    # Call hook with 'set'. If it outputs something, that will
    # be our new value (i.e. hook disagrees with the new setting!)
    commandline = "%s/lib/omd/hooks/%s set '%s'" % (g_sitedir, hookname, value) 
    if os.getuid() == 0:
        commandline = 'su - %s -c "%s"' % (g_sitename, commandline)
    answer = os.popen(commandline).read()
    if len(answer) > 0:
        value = answer.strip()

    hook["value"] = value
    config_save()

def config_usage():
    sys.stdout.write("""Usage of config command:

omd config               - interactive configuration menu
omd config show          - show current settings of all configuration variables
omd config show VAR      - show current setting of variable VAR
omd config set VAR VALUE - set VAR to VALUE
""")

def config_show(args):
    if len(args) == 0:
        hooknames = g_hooks.keys()
        hooknames.sort()
        for hookname in hooknames:
            hook = g_hooks[hookname]
            if hook["active"]:
                sys.stdout.write("%s: %s\n" % (hookname, g_hooks[hookname]["value"]))
    else:
        output = []
        for hookname in args:
            hook = g_hooks.get(hookname)
            if not hook:
                sys.stderr.write("No such variable %s\n" % hookname)
            else:
                output.append(hook["value"])

        sys.stdout.write(" ".join(output))
        sys.stdout.write("\n")

def config_configure():
    hooknames = g_hooks.keys()
    hooknames.sort()
    current_hookname = ""
    menu_open = False
    current_menu = "Basic"

    # force certain order in main menu
    menu_choices = [ "Basic", "Web GUI", "Addons", "Distributed Monitoring" ]

    while True:
        choices = []

        # Rebuild hook information (values possible changed)
        menu = {}
        for hookname in hooknames:
            hook = g_hooks[hookname]
            if hook["active"]:
                mp = hook.get("menu", "Other")
                entries = menu.get(mp, [])
                entries.append((hookname, hook["value"]))
                menu[mp] = entries
                if mp not in menu_choices:
                    menu_choices.append(mp)

        # Handle main menu
        if not menu_open:
            change, current_menu = \
                dialog_menu("Configuration of site %s" % g_sitename,
                        "Interactive setting of site configuration variables. You "
                        "can change values only while the site is stopped.",
                        [ (e, "") for e in menu_choices ],
                        current_menu,
                        "Enter",
                        "Exit")
            if not change:
                return
            current_hookname = None
            menu_open = True

        else:
            change, current_hookname = \
                dialog_menu(
                    current_menu,
                    "",
                    menu[current_menu],
                    current_hookname,
                    "Change",
                    "Main menu")
            if change:
                try:
                    config_configure_hook(current_hookname)
                except Exception, e:
                    bail_out("Error in hook %s: %s" % (current_hookname, e))
            else:
                menu_open = False


def config_configure_hook(hookname):
    if not site_is_stopped(g_sitename):
        if not dialog_yesno("You cannot change configuration value while the "
                "site is running. Do you want me to stop the site now?"):
            return
        stop_site(g_sitename)
        dialog_message("The site has been stopped.")

    hook = g_hooks[hookname]
    title = hook["alias"]
    descr = hook["description"].replace("\n\n", "\001").replace("\n", " ").replace("\001", "\n\n")
    value = hook["value"]
    choices = hook["choices"]
    if type(choices) == list:
        dialog_function = dialog_menu
    else:
        dialog_function = dialog_regex
    change, new_value = \
        dialog_function(title, descr, choices, value, "Change", "Cancel")
    if change:
        config_set_value(hook["name"], new_value)
        config_reload_hooks()

def init_action(command, args, options):
    if command == "start":
        create_tmpfs(g_sitename)

    if len(args) > 0:
        daemon = args[0] # restrict to this daemon
    else:
        daemon = None

    # OMD guarantees that we are in OMD_ROOT
    os.chdir(g_sitedir)

    if command == "status":
        return check_status(g_sitename, True, daemon, "bare" in options)
    else:
        return call_init_scripts(g_sitename, command, daemon)

# ----------------------------------------------------------
#                                                  _
#     ___ ___  _ __ ___  _ __ ___   __ _ _ __   __| |___
#    / __/ _ \| '_ ` _ \| '_ ` _ \ / _` | '_ \ / _` / __|
#   | (_| (_) | | | | | | | | | | | (_| | | | | (_| \__ \
#    \___\___/|_| |_| |_|_| |_| |_|\__,_|_| |_|\__,_|___/
#
# ----------------------------------------------------------
def main_help(args=[], options={}):
    am_root = os.getuid() == 0
    if am_root:
        sys.stdout.write("Usage (called as root):\n\n")
    else:
        sys.stdout.write("Usage (called as site user):\n\n")

    for command, only_root, needs_site, site_must_exist, confirm, synopsis, command_function, options, descr, confirm_text in commands:
        if only_root and not am_root:
            continue
        if am_root:
            if needs_site == 2:
                synopsis = "[SITE] " + synopsis
            elif needs_site == 1:
                synopsis = "SITE " + synopsis

        sys.stdout.write(" omd %-10s %-16s %s\n" % (command, synopsis, descr))
    sys.stdout.write("\nGeneral Options:\n"
                     " -V <version>                    set specific version, usefull in combination with update/create\n"
                    )

def main_setup(args, options={}):
    packages = g_info["OS_PACKAGES"].split()
    install_cmd = g_info["PACKAGE_INSTALL"]
    command = "%s %s" % (install_cmd, " ".join(packages))
    sys.stdout.write("Going to execute '%s'\n" % command)
    if 0 == os.system(command):
        ok()

    # Enable Apache modules
    for mod in [ "proxy", "proxy_http", "rewrite" ]:
        command = g_info["APACHE_ENMOD"] % mod
        if 0 != os.system(command):
            sys.stdout.write("ERROR: Could not enable Apache module mod_%s\n" % mod)

    # Activate init script of OMD and APACHE
    for service in [ 'omd',  g_info["APACHE_INIT"].split('/')[-1] ]:
        sys.stdout.write("Activating init script for \"%s\"\n" % service)
        command = g_info["ACTIVATE_INITSCRIPT"].replace("%s", service)
        sys.stdout.write("Going to execute '%s'\n" % command)
        if 0 != os.system(command):
            sys.stdout.write("ERROR\n")

    # Create group 'omd'
    if not group_exists('omd'):
        sys.stdout.write("Creating new group 'omd'\n")
        groupadd('omd')

    # set SUID bit for certain plugins (neccessary for
    # non RPM/DEB installations (FIXME: find a more elegant
    # solution later)
    gid = group_id('omd')
    for plugin in [ 'check_icmp', 'check_dhcp' ]:
        path = "/omd/versions/%s/lib/nagios/plugins/%s" % (OMD_VERSION, plugin)
        os.chown(path, -1, gid)
        os.chmod(path, 04750)


def main_uninstall(args, options={}):
    global g_sitename
    global g_sitedir
    for sitename in all_sites():
        g_sitename = sitename
        g_sitedir = site_dir(g_sitename)
        main_rm([])

    for path in [ g_info["OMD_PHYSICAL_BASE"],
                  "/omd",
		          g_info["APACHE_CONF_DIR"] + "/zzz_omd.conf",
                  "/etc/init.d/omd",
                  "/usr/bin/omd" ]:
        shutil.rmtree(path, ignore_errors=True)

    groupdel('omd')

    sys.stdout.write("Good bye.\n")


def main_setversion(args, options={}):
    if len(args) == 0:
        versions = [ (v, "Version %s" % v) for v in omd_versions() if not v == default_version() ]
        if use_update_alternatives():
            versions = [ ('auto', 'Auto (Update-Alternatives)') ] + versions
        ok, version = dialog_menu("Choose new default",
                "Please choose the version to make the new default",
                versions,
                None,
                "Make default",
                "Cancel")
        if not ok:
            bail_out("Aborted.")
    else:
        version = args[0]

    if version != 'auto' and not version in omd_versions():
        bail_out("The given version does not exist.")
    if version == default_version():
        bail_out("The given version is already default.")

    # Special handling for debian based distros which use update-alternatives
    # to control the path to the omd binary, manpage and so on
    if use_update_alternatives():
        if version == 'auto':
            os.system("update-alternatives --auto omd")
        else:
            os.system("update-alternatives --set omd /omd/versions/%s" % version)
    else:
        if os.path.exists("/omd/versions/default"):
            os.remove("/omd/versions/default")
        os.symlink("/omd/versions/%s" % version, "/omd/versions/default")


def use_update_alternatives():
    return os.path.exists("/var/lib/dpkg/alternatives/omd")


def main_version(args, options={}):
    sys.stdout.write("OMD - Open Monitoring Distribution Version %s\n" % g_info["OMD_VERSION"])


def main_versions(args, options={}):
    for v in omd_versions():
        if v == default_version() and not "bare" in options:
            sys.stdout.write("%s (default)\n" % v)
        else:
            sys.stdout.write("%s\n" % v)

def default_version():
    return os.path.basename(os.path.realpath("/omd/versions/default"))

def omd_versions():
    v = [ v for v in os.listdir("/omd/versions") if v != "default" ]
    v.sort()
    return v

def main_sites(args, options={}):
    if on_tty and not "bare" in options:
        sys.stdout.write("SITE             VERSION\n")
    for site in all_sites():
        if "bare" in options:
            sys.stdout.write("%s\n" % site)
        else:
            v = site_version(site)
            if v == default_version():
                sys.stdout.write("%-16s %s (default)\n" % (site, v))
            else:
                sys.stdout.write("%-16s %s\n" % (site, v))

# Bail out if name for new site is not valid (needed by create/mv/cp)
def sitename_must_be_valid(name):
    # Make sanity checks before starting any action
    if site_exists(name):
        bail_out("Site '%s' already existing." % name)
    if group_exists(name):
        bail_out("Group '%s' already existing." % name)
    if user_exists(name):
        bail_out("User '%s' already existing." % name)
    if not re.match("^[a-zA-Z_][a-zA-Z_0-9]{0,15}$", name):
        bail_out("Invalid site name. Must begin with a character, may contain characters, digits and _ and have length 1 up to 16")


def main_create(args, options={}):
    sitename_must_be_valid(g_sitename)

    # Create operating system user for site
    uid = options.get("uid")
    gid = options.get("gid")
    useradd(g_sitename, uid, gid)

    sitedir = site_dir(g_sitename)
    os.makedirs(sitedir)
    os.chown(sitedir, pwd.getpwnam(g_sitename).pw_uid, group_id(g_sitename))
    add_to_fstab(g_sitename)

    # Create symbolic link to version
    create_version_symlink(g_sitename, OMD_VERSION)

    # Build up directory structure with symbolic links relative to
    # the version link we just create
    for d in [ 'bin', 'include', 'lib', 'share' ]:
        os.symlink("version/" + d, sitedir + "/" + d)

    # Create skeleton files of non-tmp directories
    create_skeleton_files(g_sitename, '.')

    # Change ownership of all files and dirs to site user
    chown_tree(sitedir, g_sitename)

    # Create site.conf with default values
    config_load_hooks()
    config_set_all() # execute 'set' functions with default values
    config_save()

    # Change the few files that config save as created as root
    chown_tree(sitedir, g_sitename)

    # Create include-hook for Apache and reload apache
    create_apache_hook(g_sitename)
    sys.stdout.write("Created new site %s with version %s.\n" % (g_sitename, OMD_VERSION))
    restart_apache()

    # Mount and create contents of tmpfs. This must be done as normal
    # user. We also could do this at 'omd start', but this might confuse
    # users. They could create files below tmp which would be shadowed
    # by the mount.
    create_tmpfs(g_sitename)

    sys.stdout.write("Successfully created site %s.\n\n" % g_sitename)
    sys.stdout.write("  The site can be started with %somd start %s%s.\n" %
            (tty_bold, g_sitename, tty_normal))
    sys.stdout.write("  The default web UI is available at %shttp://%s/%s/%s\n" %
            (tty_bold, hostname(), g_sitename, tty_normal))
    sys.stdout.write("  The admin user for the web applications is %somdadmin%s with password %somd%s.\n" % (tty_bold, tty_normal, tty_bold, tty_normal))
    sys.stdout.write("  Please do a %ssu - %s%s for administration of this site.\n" %
            (tty_bold, g_sitename, tty_normal))
    sys.stdout.write("\n")



def main_rm(args, options={}):
    # omd rm is called as root but the init scripts need to be called as
    # site user but later steps need root privilegies. So a simple user
    # switch to the site user would not work. Better create a subprocess
    # for this dedicated action and switch to the user in that subprocess
    #execute_as_user(stop_site, (g_sitename, ))
    os.system('omd stop %s' % g_sitename)

    if user_logged_in(g_sitename):
        bail_out("User '%s' still logged in or running processes." % g_sitename)
    unmount_tmpfs(g_sitename)

    remove_from_fstab(g_sitename)
    sys.stdout.write("Deleting user and group %s..." % g_sitename)
    os.chdir("/") # Site dir not longer existant after userdel
    userdel(g_sitename)
    ok()

    if os.path.exists(g_sitedir): # should be done by userdel
        sys.stdout.write("Deleting all data (%s)..." % g_sitedir)
        shutil.rmtree(site_dir(g_sitename))
        ok()

    # remove include-hook for Apache and tell apache
    delete_apache_hook(g_sitename)
    restart_apache()

def main_mv_or_cp(what, args, options={}):
    action = what == "mv" and "rename" or "copy"

    global g_sitename
    global g_sitedir
    if len(args) != 1:
        bail_out("omd: Usage: omd %s oldname newname" % what)
    new = args[0]

    sitename_must_be_valid(new)

    old = g_sitename
    if not site_is_stopped(old):
        bail_out("Cannot %s site '%s' while it is running." % (action, old))

    if what == "mv":
        unmount_tmpfs(old)
        remove_from_fstab(old)

    sys.stdout.write("%sing site %s to %s..." % (what == "mv" and "Mov" or "Copy", old, new))
    sys.stdout.flush()

    # Create new user. Note: even on mv we need to create a new user.
    # Linux does not (officially) allow to rename a user.
    uid = options.get("uid")
    gid = options.get("gid")
    useradd(new, uid, gid) # None for uid/gid means: let Linux decide

    if what == "mv":
        # Rename base directory and apache config
        os.rename(site_dir(old), site_dir(new))
        delete_apache_hook(old)
    else:
        # Make exact file-per-file copy with same user but already new name
        os.mkdir(site_dir(new))
        addopts = ""
        excludes = []
        if "no-rrds" in options or "no-past" in options:
            excludes.append("var/pnp4nagios/perfdata/")
            excludes.append("var/pnp4nagios/spool/")
            excludes.append("var/rrdcached/")
            excludes.append("var/pnp4nagios/states/")
        if "no-logs" in options or "no-past" in options:
            excludes.append("var/log/*/")
            excludes.append("var/nagios/nagios.log")
            excludes.append("var/nagios/archive/")
            excludes.append("var/pnp4nagios/log/")
            excludes.append("var/pnp4nagios/perfdata.dump")
        
        for p in excludes:
            addopts += " --exclude '/%s'" % p

        if opt_verbose:
            addopts += " -v"
        
        os.system("rsync -arx %s '%s/' '%s/'" % 
                (addopts, site_dir(g_sitename), site_dir(new)))

    # give new user all files
    chown_tree(site_dir(new), new)

    # Change config files from old to new site (see rename_site())
    patch_skeleton_files(g_sitename, new)

    # In case of mv now delete old user
    if what == "mv":
        userdel(old)

    sys.stdout.write("OK\n")

    # Now switch over to the new site as currently active site
    g_sitename = new
    g_sitedir = site_dir(new)
    os.chdir(g_sitedir)
    set_environment()

    # Give hooks chance to update configuration
    refresh_hooks()

    # Entry for tmps in /etc/fstab
    add_to_fstab(new)

    # Make apache aware of new site
    create_apache_hook(new)
    restart_apache()



def diff_list(from_skelroot, g_sitedir, from_version, relbase, bare):
    """ Outputs only a list of changed/deleted files compared to the current version."""
    def print_diff(relpath, source_path, target_path, source_version, source_perms):
        source_file = source_path + '/' + relpath
        target_file = target_path + '/' + relpath

        source_perm = get_skel_permissions(source_version, source_perms, relpath)
        target_perm = get_file_permissions(target_file)

        source_type = filetype(source_file)
        target_type = filetype(target_file)

        changed_type, changed_content, changed = file_status(source_file, target_file)

        if not changed:
            return

        fn = tty_bold + tty_bgblue + tty_white + relpath + tty_normal
        fn = tty_bold + relpath + tty_normal

        def print_status(color, f, status, long_out):
            if bare:
                sys.stdout.write("%s %s\n" % (status, f))
            else:
                sys.stdout.write(color + " %s %s\n" % (long_out, f))

            # Show a little more details in verbose mode
            if opt_verbose:
                arrow = tty_magenta + '->' + tty_normal
                if 'c' in status:
                    os.system("pwd ; diff -u %s %s" % (source_file, target_file))
                elif status == 'p':
                    sys.stdout.write("    %s %s %s\n" % (source_perm, arrow, target_perm))
                elif 't' in status:
                    sys.stdout.write("    %s %s %s\n" % (source_type, arrow, target_type))

        if not target_type:
            print_status(good, fn, 'd', 'Deleted')
            return

        elif changed_type and changed_content:
            print_status(good, fn, 'tc', 'Changed type and content')

        elif changed_type and not changed_content:
            print_status(good, fn, 't', 'Changed type')

        elif changed_content and not changed_type:
            print_status(good, fn, 'c', 'Changed content')

        if source_perm != target_perm:
            print_status(warn, fn, 'p', 'Changed permissions')

    read_skel_permissions()
    old_perms = load_skel_permissions(from_version)

    if not os.path.isdir(relbase):
        print_diff(relbase, from_skelroot, g_sitedir, from_version, old_perms)
    else:
        walk_skel(from_skelroot, print_diff, (from_skelroot, g_sitedir, from_version, old_perms), relbase = relbase)


def main_diff(args, options={}):
    from_version  = site_version(g_sitename)
    from_skelroot = "/omd/versions/%s/skel" % from_version

    relbase = len(args) > 0 and args[0].rstrip('/') or '.'
    diff_list(from_skelroot, g_sitedir, from_version, relbase, "bare" in options)


def walk_skel(root, handler, args, compare_with = None, relbase = '.'):
    """
    Walks all files in the skeleton dir to execute a function for each file
    The given handler is called with the provided args. Additionally the relative
    path of the file to handle is handed over in the 'relpath' parameter.

    When called with a path in 'compare_with' the function only handles files which
    were not handled before or exist in that dir.

    The option 'relbase' is optional. It can contain a relative path which can be used
    as base for the walk instead of walking the whole tree.

    The function returns a set of already handled files.
    """
    handled_paths = set([])
    os.chdir(root)
    for dirpath, dirnames, filenames in os.walk(relbase):
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
        if dirpath.startswith("tmp"):
            continue

        for entry in dirnames + filenames:
            path = dirpath + "/" + entry
            if path.startswith("./"):
                path = path[2:]
            if compare_with and path in handled_paths:
                continue

            handled_paths.add(path)

            if not compare_with or \
               compare_with and not os.path.exists(compare_with + "/" + entry):
                try:
                    handler(path, *args)
                except Exception, e:
                    sys.stderr.write("Error updating %s/%s: %s\n" % (g_sitedir, path, e))
                    raise
    return handled_paths


def main_update(args, options={}):
    if site_is_running(g_sitename):
        bail_out("Cannot update site '%s' while it is running." % g_sitename)

    # Unmount tmp. We need to recreate the files and directories
    # from the new version after updating.
    unmount_tmpfs(g_sitename)

    # Target version: ourselves
    from_version = site_version(g_sitename)
    to_version = OMD_VERSION
    if from_version == to_version:
        possible_versions = [ v for v in omd_versions() if v != from_version ]
        possible_versions.sort(reverse=True)
        if len(possible_versions) == 0:
            bail_out("There is no other OMD version to update to.")
        elif len(possible_versions) == 1:
            to_version = possible_versions[0]
        else:
            ok, to_version = dialog_menu("Choose target version",
                    "Please choose the version this site should be updated to",
                    [ (v, "Version %s" % v) for v in possible_versions ],
                    possible_versions[0],
                    "Update now",
                    "Cancel")
            if not ok:
                bail_out("Aborted.")
        exec_other_omd(to_version)

    if not opt_force and not dialog_yesno("You are going to update the site %s from version %s to version %s. "
            "This will include updating all of you configuration files and merging "
            "changes in the default files with changes made by you. In case of conflicts "
            "your help will be needed." % (g_sitename, from_version, to_version),
            "Update!", "Abort"):
        bail_out("Aborted.")

    sys.stdout.write("Updating site '%s' from version %s to %s...\n\n" %
            (g_sitename, from_version, to_version))

    # Now apply changes of skeleton files. This can be done
    # in two ways:
    # 1. creating a patch from the old default files to the new
    #    default files and applying that to the current files
    # 2. creating a patch from the old default files to the current
    #    files and applying that to the new default files
    # We implement the first method.

    # read permissions
    read_skel_permissions()
    old_perms = load_skel_permissions(from_version)

    from_skelroot = "/omd/versions/%s/skel" % from_version
    to_skelroot = "/omd/versions/%s/skel" % to_version
    tmp = tmp_dir(g_sitename)

    # First walk through skeleton files of new version
    handled_paths = walk_skel(to_skelroot, update_file, (from_version, to_version, g_sitedir, old_perms))

    # Now handle files present in old but not in new skel files
    walk_skel(from_skelroot, update_file, (from_version, to_version, g_sitedir, old_perms), to_skelroot)

    # Change symbolic link pointing to new version
    create_version_symlink(g_sitename, to_version)

    # Let hooks do their work and update configuration
    refresh_hooks()



def main_init_action(command, args, options={}):
    global g_sitename
    global g_sitedir

    only_version = options.get("version")
    bare = "bare" in options

    # if no site is selected, all sites are affected
    if not g_sitename:
        exit_status = 0
        for site in all_sites():
            if only_version and site_version(site) != only_version:
                continue
            # We need to do an os.system(), because each
            # site must be started with the account of the
            # site user. And after setuid() we cannot return.
            if command in [ "start", "restart", "reload" ] or \
		 ( "auto" in options and command == "status" ):
                g_sitename = site
                g_sitedir = site_dir(g_sitename)
                config_load_hooks(True)
                if g_hooks["AUTOSTART"]["value"] != "on":
		    if not bare:
			sys.stdout.write("Ignoring site '%s': AUTOSTART != on\n" % site)
                    continue

	    if bare:
		sys.stdout.write('[%s]\n' % site)
	    else:
		sys.stdout.write("%sDoing '%s' on site %s:%s\n" % (tty_bold, command, site, tty_normal))
	    sys.stdout.flush()
            exit_status = max(exit_status, os.system("%s %s %s %s %s" % 
			(sys.argv[0], command, "bare" in options and "--bare" or "", site, " ".join(args))))
	    if not bare:
		sys.stdout.write("\n")
    else:
        exit_status = init_action(command, args, options)
    sys.exit(exit_status)

def main_config(args, options={}):
    config_load_hooks()
    if len(args) == 0:
        config_configure()
    else:
        command = args[0]
        args = args[1:]
        if command == "show":
            config_show(args)
        elif command == "set":
            config_set(args)
        else:
            config_usage()


commands = [
#  command   only_root  needs_site must_exist confirm args, function,
#  options_spec
#  description,
#  confirm_text
  ( "help",      False, 0, 0, False, "",        main_help,
    [],
    "Show general help",
    ""),

  ( "setup",     True,  0, 0, True, "",        main_setup,
    [],
    "Prepare operating system for OMD (installs packages)",
    "We will install missing packages from your operating system and setup the\n"
    "system apache daemon (add configuration files and modules needed by omd)\n"),

  ( "uninstall", True,  0, 0, True, "",        main_uninstall,
    [],
    "Remove OMD and all sites!",

    "BE WARNED: You are about to remove everything your system\n"
    "           have ever known about omd."),

  ( "setversion", True, 0, 0, False, "VERSION", main_setversion,
    [],
    "Sets the default version of OMD which will be used by new sites",
    ""),

  ( "version",   False, 0, 0, False, "",        main_version,
    [],
    "Show version of OMD",
    ""),

  ( "versions",  False, 0, 0, False, "",        main_versions,
    [("bare", "b", False)],
    "List installed OMD versions",
    ""),

  ( "sites",     False, 0, 0, False, "", main_sites,
    [("bare", "b", False)],
    "Show list of sites",
    ""),

  ( "create",    True,  1, 0, False, "",        main_create,
    [ ( "uid", "u", True ), ( "gid", "g", True )],
    "Create a new site (-u UID, -g GID)",

    "This command performs the following actions on your system:\n"
    "- Create the system user <SITENAME>\n"
    "- Create the system group <SITENAME>\n"
    "- Create and populate the site home directory\n"
    "- Restart the system wide apache daemon\n"
    "- Add tmpfs for the site to fstab and mount it"),

  ( "rm",        True,  1, 1, True, "",        main_rm,
    [],
    "Remove a site (and its data)",

    "PLEASE NOTE: This action removes all configuration files\n"
    "             and variable data of the site.\n"
    "\n"
    "In detail the following steps will be done:\n"
    "- Stop all processes of the site\n"
    "- Unmount tmpfs of the site\n"
    "- Remove tmpfs of the site from fstab\n"
    "- Remove the system user <SITENAME>\n"
    "- Remove the system group <SITENAME>\n"
    "- Remove the site home directory\n"
    "- Restart the system wide apache daemon\n"),

  ( "mv",        True,  1, 1, False, "NEWNAME", lambda args, opts: main_mv_or_cp("mv", args, opts),
    [ ( "uid", "u", True ), 
      ( "gid", "g", True ),
    ],
    "Rename a site",
    ""),

  ( "cp",        True,  1, 1, False, "NEWNAME", lambda args, opts: main_mv_or_cp("cp", args, opts),
    [ ( "uid", "u", True ), 
      ( "gid", "g", True ),
      ( "no-rrds", None, False ), # skip RRD files when copying site
      ( "no-logs", None, False ), # skip Logfiles when copying site
      ( "no-past", "N", False),   # skip RRDs and logfiles when copying site
    ],
    "Make a copy of a site",
    ""),

  ( "update",    False, 1, 1, False, "", main_update,
    [],
    "Update site to other version of OMD",
    ""),

  ( "start",     False, 2, 1, False, "[SERVICE]", lambda args, opts: main_init_action("start", args, opts),
    [ ( "version", "V", True ) ],
    "Start services of one or all sites",
    ""),

  ( "stop",      False, 2, 1, False, "[SERVICE]", lambda args, opts: main_init_action("stop", args, opts),
    [ ( "version", "V", True ) ],
    "Stop services of site(s)",
    ""),

  ( "restart",   False, 2, 1, False, "[SERVICE]", lambda args, opts: main_init_action("restart", args, opts),
    [ ( "version", "V", True ) ],
    "Restart services of site(s)",
    ""),

  ( "reload",    False, 2, 1, False, "[SERVICE]", lambda args, opts: main_init_action("reload", args, opts),
    [ ( "version", "V", True ) ],
    "Reload services of site(s)",
    ""),

  ( "status",    False, 2, 1, False, "[SERVICE]", lambda args, opts: main_init_action("status", args, opts),
    [ ( "version", "V", True ),
      ( "auto", None, False), 
      ( "bare", "b", False) ],
    "Show status of services of site(s)",
    ""),

  ( "config",    False, 1, 1, False, "...", main_config,
    [ ],
    "Show and set site configuration parameters",
    ""),

  ( "diff",      False, 1, 1, False, "([RELBASE])", main_diff,
    [("bare", "b", False)],
    "Shows differences compared to the original version files",
    ""),

]

def handle_global_option(opt, orig):
    global opt_verbose
    global opt_force
    global opt_interactive
    def opt_arg():
        global main_args
        if len(main_args) < 1:
            bail_out("Option %s needs an argument." % opt)
        arg = main_args[0]
        main_args = main_args[1:]
        return arg

    if opt in [ 'V', 'version' ]:
        # Switch to other version of bin/omd
        version = opt_arg()
        if version != OMD_VERSION:
            omd_path = "/omd/versions/%s/bin/omd" % version
            if not os.path.exists(omd_path):
                bail_out("OMD version '%s' is not installed." % version)
            os.execv(omd_path, sys.argv)
            bail_out("Cannot execute %s." % omd_path)
    elif opt in [ 'f', 'force' ]:
        opt_force = True
        opt_interactive = False
    elif opt in [ 'i', 'interactive' ]:
        opt_force = False
        opt_interactive = True
    elif opt in [ 'v', 'verbose' ]:
        opt_verbose = True
    else:
        bail_out("Invalid global option %s.\n"
                 "Call omd help for available options." % orig)

def parse_command_options(args, options_spec):
    options = {}
    while len(args) >= 1 and args[0][0] == '-':
        opt = args[0]
        args = args[1:]
        entries = []
        if opt.startswith("--"):
            for e in options_spec:
                if e[0] == opt[2:]:
                    entries = [e]
        else:
            for char in opt:
                for e in options_spec:
                    if e[1] == char:
                        entries.append(e)

        if len(entries) == 0:
            bail_out("Invalid option '%s'" % opt)

        for llong, sshort, needs_arg in entries:
            arg = None
            if needs_arg:
                if len(args) == 0:
                    bail_out("Option '%s' needs an argument." % opt)
                arg = args[0]
                args = args[1:]
            options[llong] = arg
    return (args, options)


def exec_other_omd(version):
    # Rerun with omd of other version
    omd_path = "/omd/versions/%s/bin/omd" % version
    if os.path.exists(omd_path):
        os.execv(omd_path, sys.argv)
        bail_out("Cannot run bin/omd of version %s." % version)
    else:
        bail_out("Site %s uses version %s which is not installed.\n"
                "Please reinstall that version and retry this command." %
                (g_sitename, version))


# ----------------------------------------------------------
#                                _
#                _ __ ___   __ _(_)_ __
#               | '_ ` _ \ / _` | | '_ \
#               | | | | | | (_| | | | | |
#               |_| |_| |_|\__,_|_|_| |_|
#
# ----------------------------------------------------------

# Handle global options. We might convert this to getopt
# later. But a problem here is that we have options appearing
# *before* the command and command specific ones. We handle
# the options before the command here only

main_args = sys.argv[1:]

while len(main_args) >= 1 and main_args[0].startswith("-"):
    opt = main_args[0]
    main_args = main_args[1:]
    if opt.startswith("--"):
        handle_global_option(opt[2:], opt)
    else:
        for c in opt[1:]:
            handle_global_option(c, opt)

if len(main_args) < 1:
    main_help()
    sys.exit(1)

command = main_args[0]
args = main_args[1:]
found = False
for c, only_root, needs_site, site_must_exist, confirm, argumentlist, command_function, option_spec, description, confirm_text in commands:
    if c == command:
        found = True
        break

if not found:
    bail_out("omd: no such command: %s" % command)

if os.getuid() != 0 and only_root:
    bail_out("omd: root permissions are needed for this command.")

# Parse command options. We need to do this now in order to know,
# if a site name has been specified or not
args, command_options = parse_command_options(args, option_spec)

# Some commands need a site to be specified. If we are
# called as root, this must be done explicitely. If we
# are site user, the site name is our user name
g_sitename = None
if needs_site > 0:
    if os.getuid() == 0:
        if len(args) >= 1:
            g_sitename = args[0]
            args = args[1:]
        elif needs_site == 1:
            bail_out("omd: please specify site.")
    else:
        g_sitename = site_name()

if g_sitename != None and site_must_exist and not site_exists(g_sitename):
    bail_out("omd: no such site: %s" % g_sitename)

# Commands operating on an existing site *must* run omd in
# the same version as the site has! Sole exception: update.
# That command must be run in the target version
if g_sitename and site_must_exist and command != "update":
    v = site_version(g_sitename)
    if OMD_VERSION != v:
        exec_other_omd(v)


if g_sitename:
    g_sitedir = site_dir(g_sitename)
else:
    g_sitedir = None

read_info()

# Commands which affect a site and can be called as root *or* as
# site user should always run with site user priviledges. That way
# we are sure that new files and processes are created under the
# site user and never as root.
if g_sitename and os.getuid() == 0 and not only_root:
    switch_to_site_user()

# Make sure environment is in a defined state
if g_sitename:
    clear_environment()
    set_environment()

if (opt_interactive or confirm) and not opt_force:
    sys.stdout.write("%s (yes/NO): " % confirm_text)
    sys.stdout.flush()
    a = sys.stdin.readline().strip()
    if a.lower() != "yes":
        sys.exit(0)

try:
    command_function(args, command_options)
except KeyboardInterrupt:
    bail_out(tty_normal + "Aborted.")
