#!/usr/bin/python

# This program is used to manage instances (create, rm, cp, mv, update)
# There is almost no error handling implemented. Please remember: this
# is a prototype, an experiment - nothing more.

import sys, os, shutil, pwd

# FIXME: Determine this somehow
OMD_VERSION = "0.42"

def bail_out(message):
    sys.stderr.write(message)
    sys.exit(1)

def omd_root():
    return "/omd/versions/" + OMD_VERSION

# Read distro- and version specific values
def read_info():
    global g_info
    g_info = {}
    info_dir = omd_root() + "/share/omd"
    for f in os.listdir(info_dir):
	if f.endswith(".info"):
	    for line in file(info_dir + "/" + f):
	       var, value = line.split('=')
	       g_info[var.strip()] = value.strip()

def site_dir(sitename):
    return "/omd/sites/" + sitename

def tmp_dir(sitename):
    return "/omd/sites/%s/tmp" % sitename

def site_exists(sitename):
    return os.path.exists(site_dir(sitename))

# Check if site is completely stopped
def site_is_stopped(sitename):
    return check_status(sitename, False) == 1

def site_is_running(sitename):
    return check_status(sitename, False) == 0

def useradd(sitename):
    # Create user for running site 'name'
    os.system("groupadd " + sitename)
    os.system("useradd -d '%s' -c 'OMD instance %s' -g %s %s -s /bin/bash" % \
                (site_dir(sitename), sitename, sitename, sitename))

    # Add Apache to new group. It needs to be able to write in to the 
    # command pipe and possible other stuff
    # FIXME: www-data is distro-specific
    os.system("gpasswd -a www-data %s >/dev/null" % sitename)

def userdel(name):
    os.system("userdel " + name)
    # FIXME: On some OSes (Debian) the group is automatically removed if
    # it bears the same name as the user
    os.system("groupdel " + name + " 2>/dev/null")

def tmpfs_mounted(sitename):
    # Problem here: if /omd is a symbolic link somewhere else,
    # then in /proc/mounts the physical path will appear and be
    # different from tmp_path. We just check the suffix therefore.
    path_suffix = "sites/%s/tmp" % sitename
    for line in file("/proc/mounts"):
        device, mp, fstype, options, dump, fsck = line.split()
        if mp.endswith(path_suffix) and fstype == 'tmpfs':
            return True
    return False

def create_tmpfs(sitename):
    if tmpfs_mounted(sitename):
        return
    tmp = tmp_dir(sitename)
    sys.stdout.write("Creating temporary filesystem...")
    sys.stdout.flush()
    if not os.path.exists(tmp):
        os.mkdir(tmp)
    if 0 != os.system("mount -t tmpfs -o mode=755,uid=%s,gid=%s tmpfs '%s'" % (sitename, sitename, tmp)):
        sys.stdout.write("ERROR\n")
        return
    create_skeleton_files(sitename, "tmp")
    chown_tree(tmp, sitename)
    sys.stdout.write("OK\n")

def unmount_tmpfs(sitename):
    if tmpfs_mounted(sitename):
        sys.stdout.write("Unmounting temporary filesystem...")
        if 0 == os.system("umount '%s'" % tmp_dir(sitename)):
            sys.stdout.write("OK\n")

def start_site(sitename):
    create_tmpfs(sitename)
    call_init_scripts(sitename, "start")

def create_site(sitename):
    if site_exists(sitename):
        bail_out("Site '%s' already existing.\n" % sitename)

    # Create operating system user for site
    useradd(sitename)

    sitedir = site_dir(sitename)
    os.makedirs(sitedir)
    os.system("chown %s:%s '%s'" % (sitename, sitename, sitedir))

    # Create symbolic link to version
    os.symlink("../../versions/%s" % OMD_VERSION, sitedir + "/version")

    # Build up directory structure with symbolic links relative to
    # the version link we just create
    for d in [ 'bin', 'include', 'lib', 'share' ]:
        os.symlink("version/" + d, sitedir + "/" + d)

    create_skeleton_files(sitename, '.')

    # Change ownership of all files and dirs to site user
    os.system("chown -R %s:%s '%s'" % (sitename, sitename, sitedir))

    # Mount and create contents of tmpfs. This needs root permissions
    # and should better not be done at start time, because then an
    # 'omd start' as site user would not work.
    create_tmpfs(sitename)    

    # Create include-hook for Apache and reload apache
    create_apache_hook(sitename)
    sys.stdout.write("Created new site %s with version %s.\n" % (sitename, OMD_VERSION))
    reload_apache()

def create_skeleton_files(sitename, dir):
    # Hack: exclude tmp if dir is '.'
    exclude_tmp = dir == '.'
    sitedir = site_dir(sitename)
    replacements = {
        "@SITE@" : sitename,
        "@ROOT@" : sitedir,
    }
    skelroot = "/omd/versions/%s/skel" % OMD_VERSION
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk(dir): 
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
        targetdir = sitedir + "/" + dirpath
        if exclude_tmp and targetdir.startswith(tmp_dir(sitename)):
            continue
        if not os.path.exists(targetdir):
            os.mkdir(targetdir)
        for d in dirnames:
            td = targetdir + "/" + d
            # Create directories with same mode as in skel
            if not os.path.exists(td):
                os.mkdir(td)
                mode = os.stat(dirpath + "/" + d).st_mode & 0xfff
                os.chmod(td, mode)
                
        for fn in filenames:
            src = dirpath + "/" + fn
            dst = targetdir + "/" + fn
            if os.path.islink(src):
                os.symlink(os.readlink(src), dst)
            else:
                create_template_instance(src, dst, replacements, sitename)

def create_apache_hook(sitename):
    file("/omd/apache/%s.conf" % sitename, "w").write("Include %s/etc/apache/*.conf\n" % site_dir(sitename))

def delete_apache_hook(sitename):
    os.remove("/omd/apache/%s.conf" % sitename)

def reload_apache():
    # FIXME: This is OS specific
    sys.stdout.write("Reloading Apache...")
    sys.stdout.flush()
    os.system("apache2ctl restart")
    sys.stdout.write("OK\n")

def create_template_instance(src, dst, replacements, sitename):
    file(dst, "w").write(replace_tags(file(src).read(), replacements))
    mode = os.stat(src).st_mode & 0xfff
    os.chmod(dst, mode)

def replace_tags(content, replacements):
    for var, value in replacements.items():
        content = content.replace(var, value)
    return content

def remove_site(sitename):
    stop_if_not_stopped(sitename)
    unmount_tmpfs(sitename)
    sys.stdout.write("Removing site %s..." % sitename)
    sys.stdout.flush()
    userdel(sitename)
    if not site_exists(sitename):
        bail_out("No such site '%s'.\n" % sitename)
    shutil.rmtree(site_dir(sitename))
    sys.stdout.write("OK\n")

    # remove include-hook for Apache and tell apache
    delete_apache_hook(sitename)
    reload_apache()

def stop_if_not_stopped(sitename):
    if not site_is_stopped(sitename):
        stop_site(sitename)

def stop_site(sitename):
    call_init_scripts(sitename, "stop")

def rename_site(old, new):
    if site_exists(new):
        bail_out("Site %s already existing.\n" % new)
    if not site_exists(old):
        bail_out("No such site '%s'.\n" % sitename)

    running = site_is_running(old)
    stop_if_not_stopped(old)
    unmount_tmpfs(old)
    sys.stdout.write("Renaming site %s to %s..." % (old, new))
    sys.stdout.flush()

    # Rename base directory and apache config
    os.rename(site_dir(old), site_dir(new))
    delete_apache_hook(old)
    create_apache_hook(new)

    # Now reflect name change in configuration files which have been
    # create from skeletons. We are only interested in plain files,
    # directories and symlinks won't change.
    patch_skeleton_files(old, new)

    # Create new user and own over all files to him. Then delete old user
    useradd(new)
    chown_tree(site_dir(new), new)
    userdel(old)

    sys.stdout.write("OK\n")

    # site was running before? Start it again
    if running:
        start_site(new)

    # Tell Apache about changes
    reload_apache()

# Change site specific information in files originally create from
# skeleton files. Skip files below tmp/
def patch_skeleton_files(old, new):
    skelroot = "/omd/versions/%s/skel" % OMD_VERSION
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk("."): 
        if dirpath.startswith("./"): 
            dirpath = dirpath[2:]
        targetdir = site_dir(new) + "/" + dirpath
        if targetdir.startswith(tmp_dir(new)):
            continue # Skip files below tmp
        for fn in filenames:
            src = dirpath + "/" + fn
            dst = targetdir + "/" + fn
            if os.path.isfile(src) and not os.path.islink(src): # links are also files??.
                patch_template_file(src, dst, old, new)

def copy_site(old, new):
    # Create an exact clone of a site.
    if site_exists(new):
        bail_out("Site %s already existing.\n" % new)
    if not site_exists(old):
        bail_out("No such site '%s'.\n" % sitename)
    
    running = site_is_running(old)
    stop_if_not_stopped(old)
    sys.stdout.write("Creating new site %s as a copy of %s..." % (new, old))
    sys.stdout.flush()
    # First make exact file-per-file copy with same
    # user but already new name
    os.mkdir(site_dir(new))
    os.system("tar cf - -C '%s' --exclude tmp . | tar xf - -C '%s'" % \
            (site_dir(old), site_dir(new)))

    # Change config files from old to new site (see rename_site())
    patch_skeleton_files(old, new)

    # Create new user and own over all files to him.
    useradd(new)
    chown_tree(site_dir(new), new)
    sys.stdout.write("OK\n")

    if running:
        start_site(old)

    # Apache hook, reload apache
    create_apache_hook(new)
    reload_apache()

def chown_tree(dir, user):
    uid = pwd.getpwnam(user).pw_uid
    gid = pwd.getpwnam(user).pw_gid
    os.chown(dir, uid, gid)
    for dirpath, dirnames, filenames in os.walk(dir): 
        for entry in dirnames + filenames:
            os.lchown(dirpath + "/" + entry, uid, gid)


def patch_template_file(src, dst, old, new):
    # Create patch from old instanciated skeleton file to new one
    content = file(src).read()
    for site in [ old, new ]:
        replacements = {
            "@SITE@" : site,
            "@ROOT@" : site_dir(site),
        }
        file("%s.skel.%s" % (dst, site), "w").write(replace_tags(content, replacements))

    # Now create patch from old to new and immediately apply on 
    # existing - possibly user modified - file.
    if 0 == os.system("diff -u %s.skel.%s %s.skel.%s | patch --force --backup --forward --silent %s" % 
            (dst, old, dst, new, dst)):
        # remove unnecessary files
        try:
            os.remove(dst + ".skel." + old)
            os.remove(dst + ".skel." + new)
            os.remove(dst + ".orig")
        except:
            pass
    else:
        sys.stdout.write("%s: Cannot update due to your changes. Please check.\n" % dst)

def init_scripts(sitename):
    rc_dir = "/omd/sites/%s/etc/rc.d" % sitename
    scripts = os.listdir(rc_dir)
    scripts.sort()
    return rc_dir, scripts

def call_init_scripts(sitename, command):
    # Call stop scripts in reverse order
    rc_dir, scripts = init_scripts(sitename)
    if command == "stop":
        scripts.reverse()
    ok = True
    for script in scripts:
        if 0 != os.system("%s/%s %s" % (rc_dir, script, command)):
            ok = False
    if ok:
         return 0
    else:
         return 2

def check_status(sitename, display=True):
    if display:
        sys.stdout.write("%s: " % sitename)
        sys.stdout.flush()
    num_running = 0
    rc_dir, scripts = init_scripts(sitename)
    for script in scripts:
        komponent = script.split("/")[-1].split('-')[-1]
        if display:
            sys.stdout.write(" %s:" % komponent)
        state = os.system("%s/%s status >/dev/null 2>&1" % (rc_dir, script))
        if state == 0:
            if display:
                sys.stdout.write("running")
            num_running += 1
        else:
            if display:
                sys.stdout.write("stopped")
    if display:
        sys.stdout.write("\n")

    if num_running == len(scripts):
        return 0 # all running
    elif num_running == 0:
        return 1 # completely stopped
    else:
        return 2 # partially running

def usage():
    sys.stdout.write("""
Usage: omd COMMAND [PARAMETERS]

  omd setup                 Install missing package of Linux distribution
  omd uninstall             Delete everything: software and sites!
  omd version               Prints the version of this program

  omd create SITE VERSION   Create new site based on version VERSION
  omd rm SITE               Delete site and all its data!
  omd cp SITE SITE2         Create new site as copy of existing one
  omd mv SITE SITE2         Rename site
  omd update SITE VERSION   Update existing site to new OMD version

  omd start SITE            Startup site
  omd stop SITE             Stop site
  omd restart SITE          Restart site
  omd reload SITE           Reload site (make config change active)
  omd status SITE           Check if site is running

  omd sites                 List all existing sites
  omd versions              List all installed versions

where:
 
 SITE ..... is the name of a site (a monitoring instance)
 VERSION .. is the name of an installed OMD version

""")

def print_version():
    sys.stdout.write("OMD - OpenSource Monitoring Distribution Version %s\n" % g_info["OMD_VERSION"])

def list_sites():
    for site in os.listdir("/omd/sites"):
	sys.stdout.write("%s\n" % site)

def list_versions():
    for version in os.listdir("/omd/versions"):
	if version != "default":
	    sys.stdout.write("%s\n" % version)

def uninstall_omd():
    for path in [ g_info["OMD_PHYSICAL_BASE"], 
		  "/omd", 
		  g_info["APACHE_CONF_DIR"] + "/omd.conf",
		  "/etc/init.d/omd",
		  "/usr/bin/omd" ]:
	os.system("rm -rf '%s'" % path)

# MAIN

read_info()
if len(sys.argv) < 2 or sys.argv[1] == "help":
    usage()
    sys.exit(0)

# FIXME: Require root permissions for several actions
command = sys.argv[1]
if command == "version":
    print_version()

elif command == "sites":
    list_sites()

elif command == "versions":
    list_versions()

elif command == "uninstall":
    uninstall_omd()

elif command == "create":
    create_site(sys.argv[2]) # should be name argument

elif command == "rm":
    remove_site(sys.argv[2])

elif command == "mv":
    rename_site(sys.argv[2], sys.argv[3])

elif command == "cp":
    copy_site(sys.argv[2], sys.argv[3])

elif command in [ "start", "stop", "restart", "reload", "status" ]:
    # if site name if not given, the site is included in our
    # executable path
    if len(sys.argv) > 2:
        sitename = sys.argv[2]
    else:
        sitename = os.path.abspath(sys.argv[0]).split('/')[3]
    if command == "start":
        create_tmpfs(sitename)
    if command == "status":
        sys.exit(check_status(sitename))
    else:
        sys.exit(call_init_scripts(sitename, command))
else:
    bail_out("Sorry. Currently only 'create' and 'rm' are implemented.\n")
