#!/usr/bin/python

# This program is used to manage instances (create, rm, cp, mv, update)
# There is almost no error handling implemented. Please remember: this
# is a prototype, an experiment - nothing more.

import sys, os, shutil, pwd, grp, re, time, pprint
from subprocess import *

OMD_VERSION = "0.13"

# colored output, if stdout is a tty
on_tty = sys.stdout.isatty()

if on_tty:
    tty_black     = '\033[30m'
    tty_red       = '\033[31m'
    tty_green     = '\033[32m'
    tty_yellow    = '\033[33m'
    tty_blue      = '\033[34m'
    tty_magenta   = '\033[35m'
    tty_cyan      = '\033[36m'
    tty_white     = '\033[37m'
    tty_bgred     = '\033[41m'
    tty_bggreen   = '\033[42m'
    tty_bgyellow  = '\033[43m'
    tty_bgblue    = '\033[44m'
    tty_bgmagenta = '\033[45m'
    tty_bgcyan    = '\033[46m'
    tty_bgwhite   = '\033[47m'
    tty_bold      = '\033[1m'
    tty_underline = '\033[4m'
    tty_normal    = '\033[0m'
    tty_ok        = tty_green + tty_bold + 'OK' + tty_normal
else:
    tty_black     = ''
    tty_red       = ''
    tty_green     = ''
    tty_yellow    = ''
    tty_blue      = ''
    tty_magenta   = ''
    tty_cyan      = ''
    tty_white     = ''
    tty_bgred     = ''
    tty_bggreen   = ''
    tty_bgyellow  = ''
    tty_bgblue    = ''
    tty_bgmagenta = ''
    tty_bgcyan    = ''
    tty_bold      = ''
    tty_underline = ''
    tty_normal    = ''
    tty_ok        = 'OK'

good = tty_bggreen + tty_white + tty_bold + "*" + tty_normal
warn = tty_bgyellow + tty_black + "?" + tty_normal
error = tty_bgred + tty_white + tty_bold + "!" + tty_normal


def have_dialog():
    return False # os.system("which dialog >/dev/null 2>&1") == 0

def ask_user(title, message, yes_text, no_text):
    if have_dialog():
        p = Popen(["dialog", "--title", title, "--shadow", "--yes-label", yes_text, "--no-label", no_text, "--yesno", message, "0", "0"])
	return 0 == os.waitpid(p.pid, 0)[1]
    else:
	sys.stdout.write(tty_bgblue + tty_white + tty_bold + title + tty_normal + ": ")
	sys.stdout.write(message + "\n")
	yes_answer = yes_text[0].lower()
	for no_answer in no_text.lower():
	    if yes_answer != no_answer:
	        break

	while True:
	    sys.stdout.write("   %s / %s  [%s/%s] ==> " %
	           	(yes_text, no_text, yes_answer.upper(), no_answer))
	    sys.stdout.flush()
	    a = sys.stdin.readline().strip().lower()
	    if not a or a == yes_answer:
		return True
	    elif a == no_answer:
		return False

def ask_user_choices(title, message, choices):
    if have_dialog():
        argv = [ "dialog", "--stderr", "--shadow", "--nocancel", "--title", title, "--menu", message, "16", "60", str(len(choices)) ]
	for c, t in choices:
	   argv += [ c, t ]
	choice = Popen(argv, stderr=PIPE).stderr.read()
        return choice.strip()	
    else:
	sys.stdout.write(tty_bgcyan + tty_white + tty_bold + title + tty_normal + "\n")
	sys.stdout.write(message + "\n\n")
	chars = []
	for choice, title in choices:
	    sys.stdout.write("  %-10s - %s\n" % (choice, title))
	    for c in choice:
		if c.lower() not in chars:
		    chars.append(c)
		    break
	sys.stdout.write("\n")

	while True:
	    sys.stdout.write("[%s] ==> " %
		    "/".join([char for (char, (c,t)) in zip(chars, choices)]))
	    sys.stdout.flush()	
	    a = sys.stdin.readline().strip().lower()
	    for char, (choice, title) in zip(chars, choices):
		if a == char:
		    return choice

def bail_out(message):
    sys.stderr.write(message)
    sys.exit(1)

def omd_root():
    return "/omd/versions/" + OMD_VERSION

# Read distro- and version specific values
def read_info():
    global g_info
    g_info = {}
    info_dir = omd_root() + "/share/omd"
    for f in os.listdir(info_dir):
	if f.endswith(".info"):
	    for line in file(info_dir + "/" + f):
	       var, value = line.split('=')
	       g_info[var.strip()] = value.strip()

def site_dir(sitename):
    return "/omd/sites/" + sitename

def tmp_dir(sitename):
    return "/omd/sites/%s/tmp" % sitename

# The version of a site is solely determined by the
# link ~SITE/version
def site_version(sitename):
    version_link = site_dir(sitename) + "/version"
    try:
        version = os.readlink(version_link).split("/")[-1]
        return version
    except:
        return None

def create_version_symlink(sitename, version):
    linkname = site_dir(sitename) + "/version"
    if os.path.exists(linkname):
	os.remove(linkname)
    os.symlink("../../versions/%s" % OMD_VERSION, linkname)


def site_exists(sitename):
    return os.path.exists(site_dir(sitename))

def all_sites():
    return [ s for s in os.listdir("/omd/sites") if s[0] != '.' ]

# Check if site is completely stopped
def site_is_stopped(sitename):
    return check_status(sitename, False) == 1

def site_is_running(sitename):
    return check_status(sitename, False) == 0

def groupdel(groupname):
    os.system("groupdel " + groupname)

def groupadd(groupname):
    os.system("groupadd " + groupname)

def useradd(sitename):
    # Create user for running site 'name'
    groupadd(sitename)
    useradd_options = g_info["USERADD_OPTIONS"]
    os.system("useradd %s -d '%s' -c 'OMD instance %s' -g %s -G omd %s -s /bin/bash" % \
                (useradd_options, site_dir(sitename), sitename, sitename, sitename))

    # Add Apache to new group. It needs to be able to write in to the 
    # command pipe and possible other stuff
    add_user_to_group(g_info["APACHE_USER"], sitename)

def add_user_to_group(user, group):
    cmd = g_info["ADD_USER_TO_GROUP"] % {"user": user, "group" : group}
    return os.system(cmd + " >/dev/null") == 0

def userdel(name):
    os.system("userdel -r " + name + " 2>/dev/null")
    # FIXME: On some OSes (Debian) the group is automatically removed if
    # it bears the same name as the user
    os.system("groupdel " + name + " 2>/dev/null")

def user_exists(name):
    try:
	pwd.getpwnam(name)
	return True
    except:
	return False

def group_exists(name):
    try:
	grp.getgrnam(name)
	return True
    except:
	return False

def user_logged_in(name):
    # Check, if processes of named user are existing
    return os.system("ps --no-headers --user '%s' >/dev/null 2>&1" % name) == 0

def switch_to_site_user():
    p = pwd.getpwnam(g_sitename)
    uid = p.pw_uid
    gid = p.pw_gid
    os.chdir(p.pw_dir)
    os.setgid(gid)
    os.setuid(uid)


def clear_environment():
    # first remove *all* current environment variables
    for key in os.environ:
        os.unsetenv(key)

def set_environment():
    os.putenv("OMD_SITE", g_sitename)
    os.putenv("OMD_ROOT", g_sitedir)
    os.putenv("PATH", "%s/local/bin:%s/bin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin" %
                                                                     (g_sitedir, g_sitedir))
    os.putenv("USER", g_sitename)
    os.putenv("LD_LIBRARY_PATH", "%s/local/lib:%s/lib" % (g_sitedir, g_sitedir))
    os.putenv("HOME", g_sitedir)

    # allow user to define further environment variable in ~/etc/environment
    envfile = g_sitedir + "/etc/environment"
    if os.path.exists(envfile):
        lineno = 0
        for line in file(envfile):
            lineno += 1
            line = line.strip()
            if line == "" or line[0] == "#":
                continue # allow empty lines and comments
            parts = line.split("=")
            if len(parts) != 2:
                bail_out("%s: syntax error in line %d\n" % (envfile, lineno))
            varname = parts[0]
            value = parts[1]
            if value.startswith('"'):
                value = value.strip('"')
            if value.startswith("'"):
                value = value.strip("'")
            os.putenv(varname, value)

def tmpfs_mounted(sitename):
    # Problem here: if /omd is a symbolic link somewhere else,
    # then in /proc/mounts the physical path will appear and be
    # different from tmp_path. We just check the suffix therefore.
    path_suffix = "sites/%s/tmp" % sitename
    for line in file("/proc/mounts"):
        device, mp, fstype, options, dump, fsck = line.split()
        if mp.endswith(path_suffix) and fstype == 'tmpfs':
            return True
    return False

def create_tmpfs(sitename):
    if tmpfs_mounted(sitename):
        return
    if os.getuid() == 0:
        switch_to_site_user()

    tmp = tmp_dir(sitename)
    sys.stdout.write("Creating temporary filesystem...")
    sys.stdout.flush()
    if not os.path.exists(tmp):
        os.mkdir(tmp)
    if 0 != os.system("mount '%s'" % tmp):
        sys.stdout.write("ERROR\n")
        return
    create_skeleton_files(sitename, "tmp")
    chown_tree(tmp, sitename)
    sys.stdout.write("OK\n")

def unmount_tmpfs(sitename):
    if tmpfs_mounted(sitename):
        sys.stdout.write("Unmounting temporary filesystem...")
	for t in range(0, 10):
	    if 0 == os.system("umount '%s'" % tmp_dir(sitename)):
	        sys.stdout.write("OK\n")
		return
	    sys.stdout.write(".")
	    sys.stdout.flush()
	    time.sleep(1)
        bail_out("Cannot unmount tmp filesystem.\n")

def add_to_fstab(sitename):
    # tmpfs                   /opt/omd/sites/b01/tmp  tmpfs   user,uid=b01,gid=b01 0 0
    mountpoint = tmp_dir(sitename)
    sys.stdout.write("Adding %s to /etc/fstab.\n" % mountpoint)
    file("/etc/fstab", "a+").write("tmpfs  %s tmpfs noauto,user,mode=755,uid=%s,gid=%s 0 0\n" % \
        (mountpoint, sitename, sitename))

def remove_from_fstab(sitename):
    mountpoint = tmp_dir(sitename)
    sys.stdout.write("Removing %s from /etc/fstab.\n" % mountpoint)
    newtab = file("/etc/fstab.new", "w")
    for line in file("/etc/fstab"):
        if "uid=%s," % sitename in line and mountpoint in line:
            continue
        newtab.write(line)
    os.rename("/etc/fstab.new", "/etc/fstab")

def start_site(sitename):
    create_tmpfs(sitename)
    call_init_scripts(sitename, "start")

def create_skeleton_files(sitename, dir):
    sitedir = site_dir(sitename)
    replacements = {
	"###SITE###" : sitename,
	"###ROOT###" : sitedir,
    }
    # Hack: exclude tmp if dir is '.'
    exclude_tmp = dir == '.'
    skelroot = "/omd/versions/%s/skel" % OMD_VERSION
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk(dir): 
        if dirpath.startswith("./"):
            dirpath = dirpath[2:]
	if dirpath == "tmp" and exclude_tmp:
	    continue # do not handle files in tmpfs
	for entry in dirnames + filenames:
	    create_skeleton_file(skelroot, sitedir, dirpath + "/" + entry, replacements)

def delete_user_file(user_path):
    if os.path.isdir(user_path):
	shutil.rmtree(user_path)
    else:
	os.remove(user_path)


def create_skeleton_file(skelbase, userbase, relpath, replacements):
    skel_path = skelbase + "/" + relpath
    user_path = userbase + "/" + relpath

    # Remove old version, if existing (needed during update)
    if os.path.exists(user_path):
	delete_user_file(user_path)

    # Create directories, symlinks and files
    if os.path.isdir(skel_path):
	os.makedirs(user_path)
    elif os.path.islink(skel_path):
        os.symlink(os.readlink(skel_path), user_path)
    else:
	file(user_path, "w").write(replace_tags(file(skel_path).read(), replacements))

    if not os.path.islink(skel_path):
	mode = os.stat(skel_path).st_mode & 0xfff
	os.chmod(user_path, mode)


def create_apache_hook(sitename):
    file("/omd/apache/%s.conf" % sitename, "w").write("Include %s/etc/apache/mode.conf\n" % site_dir(sitename))

def delete_apache_hook(sitename):
    hook_path = "/omd/apache/%s.conf" % sitename
    if not os.path.exists(hook_path):
        return
    try:
	os.remove(hook_path)
    except Exception, e:
	sys.stderr.write("Cannot remove apache hook %s: %s\n" % (hook_path, e))

def reload_apache():
    # FIXME: This is OS specific
    sys.stdout.write("Reloading Apache...")
    sys.stdout.flush()
    os.system("%s restart" % g_info["APACHE_CTL"])
    sys.stdout.write("OK\n")


def replace_tags(content, replacements):
    for var, value in replacements.items():
        content = content.replace(var, value)
    return content

def stop_if_not_stopped(sitename):
    if not site_is_stopped(sitename):
        stop_site(sitename)

def stop_site(sitename):
    call_init_scripts(sitename, "stop")


# Change site specific information in files originally create from
# skeleton files. Skip files below tmp/
def patch_skeleton_files(old, new):
    skelroot = "/omd/versions/%s/skel" % OMD_VERSION
    os.chdir(skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk("."): 
        if dirpath.startswith("./"): 
            dirpath = dirpath[2:]
        targetdir = site_dir(new) + "/" + dirpath
        if targetdir.startswith(tmp_dir(new)):
            continue # Skip files below tmp
        for fn in filenames:
            src = dirpath + "/" + fn
            dst = targetdir + "/" + fn
            if os.path.isfile(src) and not os.path.islink(src): # links are also files??.
		try:
		    patch_template_file(src, dst, old, new)
                except Exception, e:
                    sys.stderr.write("Error patching template file '%s': %s\n" %
                            (dst, e))



def chown_tree(dir, user):
    uid = pwd.getpwnam(user).pw_uid
    gid = pwd.getpwnam(user).pw_gid
    os.chown(dir, uid, gid)
    for dirpath, dirnames, filenames in os.walk(dir): 
        for entry in dirnames + filenames:
            os.lchown(dirpath + "/" + entry, uid, gid)

def instantiate_skel(path):
    t = file(path).read()
    replacements = {
        "###SITE###" : g_sitename,
        "###ROOT###" : g_sitedir,
    }
    return replace_tags(t, replacements)


def patch_template_file(src, dst, old, new):
    # Create patch from old instanciated skeleton file to new one
    content = file(src).read()
    for site in [ old, new ]:
        replacements = {
            "###SITE###" : site,
            "###ROOT###" : site_dir(site),
        }
        file("%s.skel.%s" % (dst, site), "w").write(replace_tags(content, replacements))

    # Now create patch from old to new and immediately apply on 
    # existing - possibly user modified - file.
    if 0 == os.system("diff -u %s.skel.%s %s.skel.%s | patch --force --backup --forward --silent %s" % 
            (dst, old, dst, new, dst)):
        # remove unnecessary files
        try:
            os.remove(dst + ".skel." + old)
            os.remove(dst + ".skel." + new)
            os.remove(dst + ".orig")
        except:
            pass
    else:
        sys.stdout.write("%s: Cannot update due to your changes. Please check.\n" % dst)


# Try to merge changes from old->new version and
# old->user version
def merge_update_file(relpath, old_version, new_version):
    fn = tty_bold + tty_bgblue + tty_white + relpath + tty_normal
    sys.stdout.write(warn + " Merging changes from %s to %s with your changes of %s...\n" % 
	    (old_version, new_version, fn))
	   
    replacements = {
        "###SITE###" : g_sitename,
        "###ROOT###" : g_sitedir,
    }
    user_path = g_sitedir + "/" + relpath
    content = file(user_path).read()

    for version in [ old_version, new_version ]:
	file("%s-%s" % (user_path, version), "w").write(replace_tags(file("/omd/versions/%s/skel/%s" % (version, relpath)).read(), replacements))
    version_patch = os.popen("diff -u %s-%s %s-%s" % (user_path, old_version, user_path, new_version)).read()

    # First try to merge the changes in the version into the users' file
    f = os.popen("patch --force --backup --forward --silent --merge %s" % user_path, "w")
    f.write(version_patch)
    status = f.close()
    if status:
	exitcode = status / 256
    else:
	exitcode = 0
    if exitcode == 0:
	sys.stdout.write("Successfully merged changes from %s -> %s into %s\n" % 
		(old_version, new_version, fn))
	return

    # No success. Should we try merging the users' changes onto the new file?
    # user_patch = os.popen(
    while True:
        editor = os.getenv("EDITOR", "/bin/vi")
	choice = ask_user_choices("Conflicts in " + relpath + "!", "I've tried to merge the changes from version %s to %s into %s.\n"
	   "Unfortunately there are conflicts with your changes. \n"
	   "You have the following options: " %
		( old_version, new_version, relpath ),
		[ ( "diff",    "Show differences between your and the new default version" ),
		  ( "new",     "Show what has changed from %s to %s" % (old_version, new_version) ),
		  ( "edit",    "Edit file %s (watch out for >>>>> and <<<<<)" % editor ), 
		  ( "keep",    "Keep half-merged version of the file" ),
		  ( "restore", "Restore your original version of the file" ),
		  ( "install", "Install the new default version" ),
		  ( "shell",   "Open a shell for looking around" ),
		])
	if choice == "keep":
	    break
	elif choice == "edit":
	    if 0 == os.system("%s '%s'" % (editor, user_path)):
		break
	elif choice == "diff":
	    sys.stdout.write(tty_bgmagenta + tty_white)
	    sys.stdout.flush()
	    os.system("diff -u %s.orig %s-%s" % (user_path, user_path, old_version))
	    sys.stdout.write(tty_normal)
	elif choice == "new":
	    sys.stdout.write(tty_bgmagenta + tty_white)
	    sys.stdout.flush()
	    os.system("diff -u %s-%s %s-%s" % (user_path, old_version, user_path, new_version))
	    sys.stdout.write(tty_normal)
	elif choice == "shell":
	    sys.stdout.write("Starting BASH. Type CTRL-D to continue.\n")
	    thedir = "/".join(user_path.split("/")[:-1])
	    os.system("cd '%s' ; bash -i" % thedir)
	elif choice == "keep":
	    os.rename(user_path + ".orig", user_path)
	    sys.stdout.write("Restored your version.\n")
	    break
	else:
	    os.rename("%s-%s" % (user_path, new_version), user_path)
	    sys.stdout.write("Installed default file of version %s.\n" % new_version)
	    break
	sys.stdout.write("\n\n")

    for p in [ "%s-%s" % (user_path, old_version),
	       "%s-%s" % (user_path, new_version),
	       "%s.orig" % user_path ]:
	try:
	    os.remove(p)
	except:
	    pass


def filetype(p):
    if not os.path.exists(p):
	return None
    elif os.path.islink(p):
	return "link"
    elif os.path.isdir(p):
	return "dir"
    else:
	return "file"

def update_file(old_version, new_version, userdir, relpath):
#     sys.stdout.write("Updating %s | %s | %s | %s\n" % 
# 		(old_skel, new_skel, userdir, relpath))
# 
    old_skel = "/omd/versions/%s/skel" % old_version
    new_skel = "/omd/versions/%s/skel" % new_version

    replacements = {
	"###SITE###" : g_sitename,
	"###ROOT###" : g_sitedir,
    }

    old_path = old_skel + "/" + relpath
    new_path = new_skel + "/" + relpath
    user_path = userdir + "/" + relpath

    old_type  = filetype(old_path)
    new_type  = filetype(new_path)
    user_type = filetype(user_path)

    if old_type == "file":
	old_content = instantiate_skel(old_path)

    if user_type == "file":
	user_content = file(user_path).read()

    if new_type == "file":
	new_content = instantiate_skel(new_path)

    # compare our new version with the user's version
    type_differs = user_type != new_type
    content_differs =   (user_type == "file" \
			   and new_type == "file" \
			   and user_content != new_content) or \
		           (user_type == "link" \
			    and new_type == "link" \
			    and os.readlink(user_path) != os.readlink(new_path))
    differs = type_differs or content_differs

    # compare our old version with the user's version
    user_changed_type = old_type != user_type
    user_changed_content = (old_type == "file" \
			   and user_type == "file" \
			   and old_content != user_content) or \
		           (old_type == "link" \
			    and user_type == "link" \
			    and os.readlink(old_path) != os.readlink(user_path))
    user_changed = user_changed_type or user_changed_content

    # compare our old with our new version
    we_changed_type = old_type != new_type
    we_changed_content =   (old_type == "file" \
			   and new_type == "file" \
			   and old_content != new_content) or \
		           (old_type == "link" \
			    and new_type == "link" \
			    and os.readlink(old_path) != os.readlink(new_path))
    we_changed = we_changed_type or we_changed_content


    # A --> MISSING FILES

    # Handle cases with missing files first. At least old or new are present,
    # or this function would never have been invoked.
    fn = tty_bold + tty_bgblue + tty_white + relpath + tty_normal

    # 1) New version ships new skeleton file -> simply install
    if not old_type and not user_type:
	create_skeleton_file(new_skel, userdir, relpath, replacements)
	sys.stdout.write(good + " Installed new file %s.\n" % fn)

    # 2) new version ships new skeleton file, but user's own file/dir/link
    #    is in the way.
    # 2a) the users file is identical with our new version
    elif not old_type and not differs:
    	sys.stdout.write(good + " Both you and new version created a new %s %s with the same content. Good.\n" % 
		(new_type, fn))

    # 2b) user's file has a different content or type
    elif not old_type:
	if ask_user(relpath, "The new version ships the %s %s, "
		    "but you have created a %s in that place "
		    "yourself. Shall we keep your %s or replace "
	            "is with mine?" % (new_type, relpath, user_type, user_type), "keep", "replace"):
	    sys.stdout.write(warn + " Keeping your version of %s\n" % fn)
	else:
	    create_skeleton_file(new_skel, userdir, relpath, replacements)
	    sys.stdout.write(good + " Installing new default version of %s\n" % fn)

    # 3) old version had a file which has vanished in new (got obsolete). If the user
    #    has deleted it himself, we are just happy
    elif not new_type and not user_type:
	sys.stdout.write(good + " File %s has vanished in new version. You've deleted it also. Good.\n" % fn)

    # 3b) same, but user has not deleted and changed type
    elif not new_type and user_changed_type:
	if ask_user(relpath, "The %s %s has become obsolete in "
		    "this version, but you have changed it into a "
		    "%s. Do you want to keep your %s or "
		    "may I delete it for you, please?" % (old_type, relpath, user_type, user_type),
		    "keep", "delete"):
	    sys.stdout.write(warn + " Keeping your %s\n" % fn)
	else:
	    delete_user_file(user_path)
	    sys.stdout.write(warn + " Deleted %s\n" % fn)

    # 3c) same, but user has changed it contents
    elif not new_type and user_changed_content:
	if ask_user(relpath, "The %s %s has become obsolete in "
		    "this version, but you have changed its contents. "
		    "Do you want to keep your file or "
		    "may I delete it for you, please?" % (old_type, relpath),
		    "keep", "delete"):
	    sys.stdout.write(warn + " Keeping your %s\n" % fn)
	else:
	    delete_user_file(user_path)
	    sys.stdout.write(warn + " Deleted %s\n" % fn)

    # 3d) same, but user hasn't changed anything -> silently delete
    elif not new_type:
	delete_user_file(user_path)
	sys.stdout.write(good + " File %s has vanished in new version, unchanged by you. Deleting.\n" % fn)

    # 4) old and new exist, but user file not. User has deleted that
    #    file. We simply do nothing in that case. The user surely has
    #    a good reason why he deleted the file.
    elif not user_type and not we_changed:
        sys.stdout.write(good + " You've deleted %s, which has not changed in new version. Ignoring it.\n" % fn)

    # 4b) File changed in new version. Simply warn.
    elif not user_type:
	sys.stdout.write(warn + " File %s has changed in new version, you've deleted it anyway. Ignoring.\n" % fn)
	
    # B ---> UNCHANGED, EASY CASES

    # 5) New version didn't change anything -> no need to update
    elif not we_changed:
	pass

    # 6) User didn't change anything -> take over new version
    elif not user_changed:
	create_skeleton_file(new_skel, userdir, relpath, replacements)
	sys.stdout.write(good + " Installed new version of %s.\n" % fn)

    # 7) User changed, but accidentally exactly as we did -> no action neccessary
    elif not differs: 
	sys.stdout.write(good + " You've changed %s exactly as in the new version. Keeping.\n" % fn)
    
    # TEST UNTIL HERE

    # C ---> PATCH DAY, HANDLE FILES
    # 7) old, new and user are files. And all are different
    elif old_type == "file" and new_type == "file" and user_type == "file":
	merge_update_file(relpath, old_version, new_version)

    # D ---> SYMLINKS
    # 8) all are symlinks, all changed
    elif old_type == "link" and new_type == "link" and user_type == "link":
	if ask_user(relpath, "'%s' is a symlink that pointed to "
		"%s in the old version and to "
		"%s in the new version. But meanwhile you "
		"changed to link target to %s. "
		"Shall I keep your link or replace it with " 
		"the new default target?" % 
		(relpath, os.readlink(old_path), os.readlink(new_path), os.readlink(user_path)),
		"keep", "replace"):
	    sys.stdout.write(warn + " Keeping your link %s\n" % fn)
	else:
	    os.remove(user_path)
	    os.symlink(os.readlink(new_path), user_path)
	    sys.stdout.write(warn + " Set link %s to new target %s\n" % (fn, os.readline(new_path)))

    # E ---> FILE TYPE HAS CHANGED (NASTY)
    # Now we have to handle cases, where the file types of the three
    # versions are not identical and at the same type the user or
    # have changed the third file to. We cannot merge here, the user
    # has to decide wether to keep his version of use ours.

    # 9) We have changed to file type
    elif old_type != new_type:
	if ask_user(relpath, "The %s %s has changed into a %s in "
		"the new version. Meanwhile you have changed "
		"the %s of your copy of that %s. "
		"Do you want to keep your version or use "
		"the new default? " % 
		(old_type, relpath, new_type, user_changed_type and "type" or "content",
		 old_type),
		"keep", "use new"):
	    sys.stdout.write(warn + " Keeping your version of %s" % fn)
	else:
	    create_skeleton_file(new_skel, userdir, relpath, replacements)
	    sys.stdout.write(warn + " Replaced your %s %s by new default %s.\n" % (user_type, relpath, new_type))
	    

    # 10) The user has changed the file type, we just the content
    elif old_type != user_type:
	if ask_user(relpath, "Usually %s is a %s in both the "
		"old and new version. But you have changed it "
		"into a %s. Do you want to keep that of may "
		"I replace your %s with the new default "
		"%s, please?" % 
		(relpath, old_type, user_type, new_type),
		"keep", "replace"):
	    sys.stdout.write(warn + " Keeping your %s %s.\n" % (user_type, fn))
	else:
	    create_skeleton_file(new_skel, userdir, relpath, replacements)
	    sys.stdout.warn(warn + " Delete your %s and created new default %s %s.\n" % (user_type, new_type, fn))

    # 11) This case should never happen, if I've not lost something
    else:
	if ask_user(relpath, "You somehow fiddled along with "
	       "%s, and I do not have the "
	       "slightest what's going on here. May "
	       "I please install the new default %s "
	       "here, or do you want to keep your %s?" % 
	       (relpath, new_type, user_type),
	       "keep", "install new"):
	    sys.stdout.write(warn + " Keeping your %s %s.\n" % (user_type, fn))
	else:
	    create_skeleton_file(new_skel, userdir, relpath, replacements)
	    sys.stdout.warn(warn + " Delete your %s and created new default %s %s.\n" % (user_type, new_type, fn))

def init_scripts(sitename):
    rc_dir = "/omd/sites/%s/etc/rc.d" % sitename
    try:
        scripts = os.listdir(rc_dir)
        scripts.sort()
        return rc_dir, scripts
    except:
        return rc_dir, []

def call_init_scripts(sitename, command):
    # Restart: Do not restart each service after another, 
    # but first do stop all, then start all again! This
    # preserves the order.
    if command == "restart":
        call_init_scripts(sitename, "stop")
        call_init_scripts(sitename, "start")
        return

    # Call stop scripts in reverse order
    rc_dir, scripts = init_scripts(sitename)
    if command == "stop":
        scripts.reverse()
    ok = True
    for script in scripts:
        if 0 != os.system("%s/%s %s" % (rc_dir, script, command)):
            ok = False
    if ok:
         return 0
    else:
         return 2

def check_status(sitename, display=True):
    if display:
        sys.stdout.write("%s: " % sitename)
        sys.stdout.flush()
    num_running = 0
    num_unused = 0
    rc_dir, scripts = init_scripts(sitename)
    for script in scripts:
        komponent = script.split("/")[-1].split('-')[-1]
        if display:
            sys.stdout.write(" %s:" % komponent)
        state = os.system("%s/%s status >/dev/null 2>&1" % (rc_dir, script)) >> 8
        if display: 
            sys.stdout.write(tty_bold)
        if state == 0:
            if display:
                sys.stdout.write(tty_green + "running")
            num_running += 1
        elif state == 5:
            if display:
                sys.stdout.write(tty_blue + "unused")
            num_unused += 1
        else:
            if display:
                sys.stdout.write(tty_red + "stopped")
        if display:
            
            sys.stdout.write(tty_normal)
    if display:
        sys.stdout.write("\n")

    if num_running == 0:
        return 1 # completely stopped
    elif num_running + num_unused == len(scripts):
        return 0 # all running
    else:
        return 2 # partially running


def config_load():
    confpath = g_sitedir + "/etc/omd/site.conf"
    if not os.path.exists(confpath):
        return

    for line in file(confpath):
	line = line.strip()
	if line == "" or line[0] == "#": 
	    continue
	var, value = line.split("=", 1)
	value = value.strip('"').strip("'")
	var = var.strip()
        if not var.startswith("CONFIG_"):
            sys.stderr.write("Ignoring invalid variable %s.\n" % var)
        else:
            var = var[7:]
            if not var in g_hooks:
                sys.stderr.write("Ignoring undefined variable %s.\n" % var)
            else:
                g_hooks[var]["value"] = value

def config_save():
    confdir = g_sitedir + "/etc/omd"
    if not os.path.exists(confdir):
        os.mkdir(confdir)
    f = file(g_sitedir + "/etc/omd/site.conf", "w")
    hooknames = g_hooks.keys()
    hooknames.sort()
    for hookname in hooknames:
        hook = g_hooks[hookname]
	f.write("CONFIG_%s='%s'\n" % (hookname, hook["value"]))

# Get information about all hooks
def config_load_hooks():
    global g_hooks
    g_hooks = {}
    hook_dir = g_sitedir + "/lib/omd/hooks"
    for hookname in os.listdir(hook_dir):
	if hookname[0] != '.':
	     g_hooks[hookname] = config_load_hook(hookname)
    # now load actual values from site.conf, if available
    config_load()

def call_hook(hookname, args):
    hook_file = g_sitedir + "/lib/omd/hooks/" + hookname
    argsstring = " ".join([ "'%s'" % arg for arg in args ])
    os.putenv("OMD_ROOT", g_sitedir)
    os.putenv("OMD_SITE", g_sitename)
    return os.popen(hook_file + " " + argsstring).read().strip()

def config_load_hook(hookname): 

    def get_hook_info(info):
	return call_hook(hookname, [info])

    hook = {}
    hook["alias"] = get_hook_info("alias")
    hook["description"] = get_hook_info("alias")
    hook["default"] = get_hook_info("default")
    hook["value"] = hook["default"]
    # The choices can either be a list of possible keys. Then
    # the hook outputs one live for each choice where the key and a
    # description are separated by a colon. Or it outputs one line
    # where that line is an extended regular expression matching the
    # possible values.
    choicestxt = get_hook_info("choices").split("\n")
    if len(choicestxt) == 1:
        choices = re.compile(choicestxt[0] + "$")
    else:
        choices = []
        try:
            for line in choicestxt:
                val, descr = line.split(":", 1)
                val = val.strip()
                descr = descr.strip()
                choices.append( (val, descr) )
        except:
            sys.stderr.write("Invalid output of hook: %s\n" % choicestxt)
            sys.exit(1)
            
    hook["choices"] = choices
    return hook


def config_set(args):
    if len(args) != 2:
	sys.stderr.write("Please specify variable name and value\n")
	config_usage()
	return

    if not site_is_stopped(g_sitename):
        sys.stderr.write("Cannot change config variables while site is running.\n")
        return

    hookname = args[0]
    value = args[1]
    hook = g_hooks.get(hookname)
    if not hook:
	sys.stderr.write("No such variable '%s'\n" % hookname)
	return

    # Check if value is valid. Choices are either a list of allowed
    # keys or a regular expression
    if type(hook["choices"]) == list:
        choices = [ var for (var, descr) in hook["choices"] ]
        if value not in choices:
            sys.stderr.write("Invalid value for '%s'. Allowed are: %s\n" % \
                    (value, ", ".join(choices)))
            return
    else:
        if not hook["choices"].match(value):
            sys.stderr.write("Invalid value for '%s'. Does not match allowed pattern.\n" % value)
            return

    config_set_value(hookname, value)

def config_set_all():
    for hookname, hook in g_hooks.items():
        config_set_value(hookname, hook["value"])

def config_set_value(hookname, value):
    hook = g_hooks.get(hookname)
    hook["value"] = value
    config_save()
    os.system("%s/lib/omd/hooks/%s set '%s'" % (g_sitedir, hookname, value))

def config_usage():
    sys.stdout.write("""Usage of config command:

omd config show          - show current settings of all configuration variables
omd config show VAR      - show current setting of variable VAR
omd config set VAR VALUE - set VAR to VALUE
omd config choices VAR   - show allowed values for VAR
""")

def config_show(args):
    if len(args) == 0:
	hooknames = g_hooks.keys()
	hooknames.sort()
	for hookname in hooknames:
	    sys.stdout.write("%s: %s\n" % (hookname, g_hooks[hookname]["value"]))
    else:
        output = []
        for hookname in args:
            hook = g_hooks.get(hookname)
            if not hook:
                sys.stderr.write("No such variable %s\n" % hookname)
            else:
                output.append(hook["value"])
	sys.stdout.write(" ".join(output))
	sys.stdout.write("\n")


def init_action(command):
    if command == "start":
        create_tmpfs(g_sitename)
    if command == "status":
        return check_status(g_sitename)
    else:
        return call_init_scripts(g_sitename, command)

# ----------------------------------------------------------
#                                                  _     
#     ___ ___  _ __ ___  _ __ ___   __ _ _ __   __| |___ 
#    / __/ _ \| '_ ` _ \| '_ ` _ \ / _` | '_ \ / _` / __|
#   | (_| (_) | | | | | | | | | | | (_| | | | | (_| \__ \
#    \___\___/|_| |_| |_|_| |_| |_|\__,_|_| |_|\__,_|___/
#                                                        
# ----------------------------------------------------------
def main_help(args=[]):
    am_root = os.getuid() == 0
    if am_root:
        sys.stdout.write("Usage (called as root):\n\n")
    else:
        sys.stdout.write("Usage (called as site user):\n\n")

    for command, only_root, needs_site, site_must_exist, confirm, synopsis, command_function, descr, confirm_text in commands:
        if only_root and not am_root:
            continue
        if am_root:
            if needs_site == 2:
                synopsis = "[SITE] " + synopsis
            elif needs_site == 1:
                synopsis = "SITE " + synopsis

        sys.stdout.write(" omd %-10s %-16s %s\n" % (command, synopsis, descr))

def main_setup(args):
    packages = g_info["OS_PACKAGES"].split()
    install_cmd = g_info["PACKAGE_INSTALL"]
    command = "%s %s" % (install_cmd, " ".join(packages))
    sys.stdout.write("Going to execute '%s'\n" % command)
    if 0 == os.system(command):
        sys.stdout.write("OK.\n")

    # Enable Apache modules
    for mod in [ "proxy", "proxy_http" ]:
        command = g_info["APACHE_ENMOD"] % mod
        if 0 != os.system(command):
            sys.stdout.write("ERROR: Could not enable Apache module mod_%s\n" % mod)

    # Activate init script of OMD
    sys.stdout.write("Installing and activating /etc/init.d/omd\n")
    command = g_info["ACTIVATE_INITSCRIPT"].replace("%s", "omd")
    if 0 != os.system(command):
        sys.stdout.write("ERROR\n")
        
    # Create group 'omd'
    if not group_exists('omd'):
        sys.stdout.write("Creating new group 'omd'\n")
        groupadd('omd')

    # set SUID bit for certain plugins (neccessary for 
    # non RPM/DEB installations (FIXME: find a more elegant
    # solution later)
    for plugin in [ 'check_icmp', 'check_dhcp' ]:
        path = "/omd/versions/%s/lib/nagios/plugins/%s" % (OMD_VERSION, plugin)
        os.system("chgrp omd '%s'" % path)
        os.system("chmod 4750 '%s'" % path)


def main_uninstall(args):
    global g_sitename
    global g_sitedir
    for sitename in all_sites():
	g_sitename = sitename
        g_sitedir = site_dir(g_sitename)
	main_rm([])

    for path in [ g_info["OMD_PHYSICAL_BASE"], 
		  "/omd", 
		  g_info["APACHE_CONF_DIR"] + "/zzz_omd.conf",
		  "/etc/init.d/omd",
		  "/usr/bin/omd" ]:
	os.system("rm -rf '%s'" % path)
        
    groupdel('omd')

    sys.stdout.write("Good bye.\n")


def main_version(args):
    sys.stdout.write("OMD - OpenSource Monitoring Distribution Version %s\n" % g_info["OMD_VERSION"])

def main_versions(args):
    for version in os.listdir("/omd/versions"):
	if version != "default":
	    sys.stdout.write("%s\n" % version)

def main_sites(args):
    if on_tty:
	sys.stdout.write("SITE             VERSION\n")
    for site in all_sites():
	sys.stdout.write("%-16s %s\n" % (site, site_version(site)))

def main_create(args):
    # Make sanity checks before starting any action
    if site_exists(g_sitename):
        bail_out("Site '%s' already existing.\n" % g_sitename)
    if group_exists(g_sitename):
        bail_out("Group '%s' already existing.\n" % g_sitename)
    if user_exists(g_sitename):
        bail_out("User '%s' already existing.\n" % g_sitename)
    if not re.match("^[a-zA-Z_][a-zA-Z_0-9]{0,15}$", g_sitename):
	bail_out("Invalid site name. Must begin with a character, may contain characters, digits and _ and have length 1 up to 16\n")


    # Create operating system user for site
    useradd(g_sitename)

    sitedir = site_dir(g_sitename)
    os.makedirs(sitedir)
    os.system("chown %s:%s '%s'" % (g_sitename, g_sitename, sitedir))
    add_to_fstab(g_sitename)

    # Create symbolic link to version
    create_version_symlink(g_sitename, OMD_VERSION)

    # Build up directory structure with symbolic links relative to
    # the version link we just create
    for d in [ 'bin', 'include', 'lib', 'share' ]:
        os.symlink("version/" + d, sitedir + "/" + d)

    create_skeleton_files(g_sitename, '.')

    # Create site.conf with default values
    config_load_hooks()
    config_set_all() # execute 'set' functions with default values
    config_save()

    # Change ownership of all files and dirs to site user
    os.system("chown -R %s:%s '%s'" % (g_sitename, g_sitename, sitedir))

    # Create include-hook for Apache and reload apache
    create_apache_hook(g_sitename)
    sys.stdout.write("Created new site %s with version %s.\n" % (g_sitename, OMD_VERSION))
    reload_apache()

    # Mount and create contents of tmpfs. This must be done as normal
    # user. We also could do this at 'omd start', but this might confuse
    # users. They could create files below tmp which would be shadowed
    # by the mount.
    create_tmpfs(g_sitename)    


def main_rm(args):
    stop_if_not_stopped(g_sitename)
    if user_logged_in(g_sitename):
        bail_out("User '%s' still logged in or running processes.\n" % g_sitename)
    unmount_tmpfs(g_sitename)

    sys.stdout.write("Removing site %s..." % g_sitename)
    remove_from_fstab(g_sitename)
    sys.stdout.flush()
    userdel(g_sitename)
    if os.path.exists(g_sitedir): # should be done by userdel
        shutil.rmtree(site_dir(g_sitename))
    sys.stdout.write("OK\n")

    # remove include-hook for Apache and tell apache
    delete_apache_hook(g_sitename)
    reload_apache()

def main_mv(args):
    if len(args) != 1:
	bail_out("omd: Usage: omd mv oldname newname\n")
    new = args[0]
    
    if site_exists(new):
        bail_out("Site %s already existing.\n" % new)

    old = g_sitename
    if site_is_running(old):
	bail_out("Cannot rename site '%s' while it is running.\n" % old)

    unmount_tmpfs(old)
    remove_from_fstab(old)
    sys.stdout.write("Renaming site %s to %s..." % (old, new))
    sys.stdout.flush()

    # Rename base directory and apache config
    os.rename(site_dir(old), site_dir(new))
    delete_apache_hook(old)
    create_apache_hook(new)

    # Now reflect name change in configuration files which have been
    # create from skeletons. We are only interested in plain files,
    # directories and symlinks won't change.
    patch_skeleton_files(old, new)

    # Create new user and own over all files to him. Then delete old user
    useradd(new)
    chown_tree(site_dir(new), new)
    userdel(old)

    sys.stdout.write("OK\n")
    add_to_fstab(new)

    # Tell Apache about changes
    reload_apache()

def main_cp(args):
    if len(args) != 1:
	bail_out("omd: Usage: omd cp oldname newname\n")
    new = args[0]
    
    if site_exists(new):
        bail_out("Site %s already existing.\n" % new)

    old = g_sitename
    if site_is_running(old):
	bail_out("Cannot copy while site '%s' is still running.\n" % old)

    sys.stdout.write("Creating new site %s as a copy of %s..." % (new, g_sitename))
    sys.stdout.flush()
    # First make exact file-per-file copy with same
    # user but already new name
    os.mkdir(site_dir(new))
    os.system("rsync -arx '%s/' '%s/'" % (site_dir(g_sitename), site_dir(new)))
    # os.system("tar cf - -C '%s' --exclude tmp . | tar xf - -C '%s'" % \
    #         (site_dir(g_sitename), site_dir(new)))

    # Change config files from old to new site (see rename_site())
    patch_skeleton_files(g_sitename, new)

    # Create new user and own over all files to him.
    useradd(new)
    chown_tree(site_dir(new), new)
    sys.stdout.write("OK\n")

    # Entry for tmps in /etc/fstab
    add_to_fstab(new)

    # Apache hook, reload apache
    create_apache_hook(new)
    reload_apache()

def main_update(args):
    if site_is_running(g_sitename):
	bail_out("Cannot update site '%s' while it is running.\n" % g_sitename)
    
    # Unmount tmp. We need to recreate the files and directories
    # from the new version after updating.
    unmount_tmpfs(g_sitename)

    # Target version: ourselves
    from_version = site_version(g_sitename)
    to_version = OMD_VERSION
    if from_version == to_version:
	bail_out("Site '%s' already has version %s.\n" % (g_sitename, to_version))	
    sys.stdout.write("Updating site '%s' from version %s to %s...\n" % 
	    (g_sitename, from_version, to_version))

    # Now apply changes of skeleton files. This can be done
    # in two ways: 
    # 1. creating a patch from the old default files to the new
    #    default files and applying that to the current files
    # 2. creating a patch from the old default files to the current
    #    files and applying that to the new default files
    # We implement the first method.

    from_skelroot = "/omd/versions/%s/skel" % from_version
    to_skelroot = "/omd/versions/%s/skel" % to_version
    tmp = tmp_dir(g_sitename)

    handled_paths = set([])
    # First walk through skeleton files of new version
    os.chdir(to_skelroot)  # make relative paths
    for dirpath, dirnames, filenames in os.walk("."): 
        if dirpath.startswith("./"): 
            dirpath = dirpath[2:]
	if dirpath.startswith("tmp"):
	    continue

	for entry in dirnames + filenames:
	    path = dirpath + "/" + entry
	    handled_paths.add(path)
	    try:
		update_file(from_version, to_version, g_sitedir, path)
	    except Exception, e:
		sys.stderr.write("Error updating %s/%s: %s\n" % (g_sitedir, entry, e))	
		raise

    # Now handle files present in old but not in new skel files
    os.chdir(from_skelroot)
    for dirpath, dirnames, filenames in os.walk("."): 
        if dirpath.startswith("./"): 
            dirpath = dirpath[2:]
	if dirpath.startswith("tmp"):
	    continue

	for entry in dirnames + filenames:
	    path = dirpath + "/" + entry
	    if path in handled_paths:
		continue
	    handled_paths.add(path)
	    # handle only files not already handled while scanning to_skelroot
	    if not os.path.exists(to_skelroot + "/" + entry):
		try:
		    update_file(from_version, to_version, g_sitedir, path)
		except Exception, e:
		    sys.stderr.write("Error updating %s/%s: %s\n" % (g_sitedir, entry, e))	
		    raise

    # Finally change symbolic link pointing to new version
    create_version_symlink(g_sitename, to_version)



def main_init_action(command, args):
    global g_sitename
    global g_sitedir
    # if no site is selected, all sites are affected
    if not g_sitename:
        exit_status = 0
	for site in all_sites():
            # We need to do an os.system(), because each
            # site must be started with the account of the
            # site user. And after setuid() we cannot return.
            if command in [ "start", "restart", "reload" ]:
                g_sitename = site
                g_sitedir = site_dir(g_sitename)
                config_load_hooks()
                if g_hooks["AUTOSTART"]["value"] != "on":
                    sys.stdout.write("%sIgnoring site '%s': AUTOSTART != on%s\n" 
                            % (tty_bold + tty_yellow, site, tty_normal))
                    continue
            
            sys.stdout.write("%sDoing '%s' on site %s:%s\n" % (tty_bold, command, site, tty_normal))
            exit_status = max(exit_status, os.system("%s %s %s %s" % (sys.argv[0], command, site, " ".join(args))))
    else:
	exit_status = init_action(command)
    sys.exit(exit_status)

def main_config(args):
    config_load_hooks()
    if len(args) == 0:
	args = [ "show" ]
    command = args[0]
    args = args[1:]
    if command == "show":
	config_show(args)
    elif command == "set":
	config_set(args)
    else:
	config_usage()


# ----------------------------------------------------------
#                                _       
#                _ __ ___   __ _(_)_ __  
#               | '_ ` _ \ / _` | | '_ \ 
#               | | | | | | (_| | | | | |
#               |_| |_| |_|\__,_|_|_| |_|
#                                        
# ----------------------------------------------------------

# If command that refer to a site are called as root
# the site is always the parameter right after the command
# name

commands = [
#  command   only_root  needs_site must_exist confirm args, function, description, confirm_text
  ( "help",      False, 0, 0, False, "",        main_help,
    "Show general help",
    ""),

  ( "setup",     True,  0, 0, True, "",        main_setup,
    "Prepare operating system for OMD (installs packages)",
    "We will install missing packages from your operating system and setup Apache"),

  ( "uninstall", True,  0, 0, True, "",        main_uninstall,
    "Remove OMD and all sites!",

    "BE WARNED: You are about to remove everything your system\n"
    "           have ever known about omd."),

  ( "version",   False, 0, 0, False, "",        main_version,
    "Show version of OMD",
    ""),

  ( "versions",  False, 0, 0, False, "",        main_versions,
    "List installed OMD versions",
    ""),

  ( "sites",     False, 0, 0, False, "", main_sites,
    "Show list of sites",
    ""),

  ( "create",    True,  1, 0, False, "",        main_create,
    "Create a new site",

    "This action performs the following actions on your system:\n"
    "- The user XY is being created\n"
    "- FIXME..."),

  ( "rm",        True,  1, 1, True, "",        main_rm,
    "Remove a site (and its data)",

    "PLEASE NOTE: This action removes all configuration files\n"
    "             and variable data of site XY\n"),

  ( "mv",        True,  1, 1, False, "NEWNAME", main_mv,
    "Rename a site",

    "The site XY will be renamed to Z."),

  ( "cp",        True,  1, 1, False, "NEWNAME", main_cp,
    "Make a copy of a site",

    "The whole site Xy will be copied to Z. A new system user Z will be created.\n"),

  ( "update",    False, 1, 1, False, "", main_update,
    "Update site to version " + OMD_VERSION,
    ""),

  ( "start",     False, 2, 1, False, "", lambda args: main_init_action("start", args),
    "Start services of one or all sites",
    ""),

  ( "stop",      False, 2, 1, False, "", lambda args: main_init_action("stop", args),
    "Stop services of site(s)",
    ""),

  ( "restart",   False, 2, 1, False, "", lambda args: main_init_action("restart", args),
    "Restart services of site(s)",
    ""),

  ( "reload",    False, 2, 1, False, "", lambda args: main_init_action("reload", args),
    "Reload services of site(s)",
    ""),

  ( "status",    False, 2, 1, False, "", lambda args: main_init_action("status", args),
    "Show status of services of site(s)",
    ""),

  ( "config",    False, 1, 1, False, "...", main_config,
    "Show and set site configuration parameters",
    ""),

]

if len(sys.argv) < 2:
    main_help()
    sys.exit(1)

command = sys.argv[1]
args = sys.argv[2:]
found = False
for c, only_root, needs_site, site_must_exist, confirm, argumentlist, command_function, description, confirm_text in commands:
    if c == command:
        found = True
	break

if not found:
    bail_out("omd: no such command: %s\n" % command)

if os.getuid() != 0 and only_root:
    bail_out("omd: root permissions are needed for this command.\n")

# Some commands need a site to be specified. If we are
# called as root, this must be done explicitely. If we
# are site user, the site name is our user name
g_sitename = None
if needs_site > 0:
    if os.getuid() == 0:
	if len(args) >= 1:
	    g_sitename = args[0]
	    args = args[1:]
        elif needs_site == 1:
	    bail_out("omd: please specify site.\n")
    else:
        g_sitename = pwd.getpwuid(os.getuid()).pw_name

if g_sitename != None and site_must_exist and not site_exists(g_sitename):
    bail_out("omd: no such site: %s\n" % g_sitename)

# Commands operating on an existing site *must* run omd in
# the same version as the site has! Sole exception: update.
# That command must be run in the target version
if g_sitename and site_must_exist and command != "update":
    v = site_version(g_sitename)
    if OMD_VERSION != v:
        # Rerun with omd of correct version
        omd_path = "/omd/versions/%s/bin/omd" % v
        if os.path.exists(omd_path):
            os.execv("/omd/versions/%s/bin/omd" % v, sys.argv)
	    bail_out("Cannot run bin/omd of version %s.\n" % v)


if g_sitename:
    g_sitedir = site_dir(g_sitename)
else:
    g_sitedir = None

read_info()

# Commands which affect a site and can be called as root *or* as 
# site user should always run with site user priviledges. That way 
# we are sure that new files and processes are created under the 
# site user and never as root.
if g_sitename and os.getuid() == 0 and not only_root:
    switch_to_site_user()

# Make sure environment is in a defined state
if g_sitename:
    clear_environment()
    set_environment()

if confirm:
    sys.stdout.write("%s (yes/NO): " % confirm_text)
    sys.stdout.flush()
    a = sys.stdin.readline().strip()
    if a.lower() != "yes":
	sys.exit(0)

command_function(args)
